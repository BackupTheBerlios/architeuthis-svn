%% Realease 1.0 dieser Software wurde am Institut für Intelligente Systeme der
%% Universität Stuttgart (http://www.informatik.uni-stuttgart.de/ifi/is/) unter
%% Leitung von Dietmar Lippold (dietmar.lippold@informatik.uni-stuttgart.de)
%% entwickelt.

\chapter[Benutzung als Dispatcher -Administrator]{Die Benutzung des Systems als
  Dispatcher-Administrator}

\section{Der Dispatcher}
\subsection*{Kurzbeschreibung}
Der Dispatcher besteht aus drei Komponenten: Dem Compute-Manager,
dem Problem-Manager und der Statistik. Er ist das Herzst"uck des 
Compute-Systems. 

\subsection{Voraussetzungen}
Benötigt wird zunächst ein funktionierendes Java Runtime Environment, Version
1.4 oder neuer. Es ist eine Netzwerkanbindung n"otig, damit eine Kommunikation
zu den Operatives geschaffen werden kann. Besondere Hardware-Anforderungen
werden nicht gestellt, ein Rechner mit 600 MHz und 256MB RAM kann problemlos 
als Dispatcher für über 30 Operatives dienen.

\subsection{Benutzung}
Um den Dispatcher benutzen zu können, muss er auf einem von allen
Operatives erreichbaren Computer gestartet werden. Dieser Computer muss
auch für Anfragen von den Computern offen sein, die später Probleme auf den
Dispatcher übertragen wollen.
Wie später beim Operative gilt auch hier: Am besten läuft der
Dispatcher mit angepaßter Priorität im Hintergrund.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}
Kommandozeile zum Starten des Dispatchers (alles in einer Zeile, die
Zeilenumbrüche wurden nur zur besseren Übersicht eingefügt):\\

{\tt java -Djava.rmi.server.RMIClassLoaderSpi=\\
  de.unistuttgart.architeuthis.dispatcher.problemmanaging.CacheFlushingRMIClSpi\\
  -Djava.util.logging.config.file=logging.properties\\
  -Djava.security.policy=dispatcher.pol\\
  de.unistuttgart.architeuthis.dispatcher.DispatcherImpl\\
  -c <config-Datei> -port <Port-Nummer>\\
  -deadtime <Zeit> -deadtries <Anzahl>}\\

Dabei: 
\begin{description}
\item[-Djava.rmi...CacheFlushingRMIClSp] Optional. Hiermit werden die Klassen 
  von Problemen nur gecached, solange das Problem in Berechnung ist,
  sobald die Lösung dem Benutzer zurückübermittelt wurde, werden die
  dazugehörigen Klassen aus dem Cache gelöscht. Damit können Probleme,
  deren Klassen modifiziert wurden, dem Compute-System wieder zum 
  Berechnen übergeben werden. Normalerweise würde das Java-eigene
  cachen von Klassen dies verhindern.
  \par {\bf Achtung:} Selbst durch diese Massnahme kann es zu merkwürdigen
  Effekten kommen (z.B. ClassCast-Exception), wenn mehrere Probleme
  gleichzeitig in modifizierter Form berechnet werden, oder wenn
  mehrere Probleme im gleichen Verzeichnis des Webservers bereitgestellt
  werden. Es ist auch keine mehrfache Berechnung eine einzelnen Problems
  gleichzeitig möglich. Daher sollte am Einfachsten für jedes neue
  Problem auch ein neues Verzeichnis auf dem Webserver angelegt werden. Dann
  treten die oben angedeuteten Probleme nicht mehr auf.

\item[-Djava.util.logging.config.file=logging.properties]
  Optional. Gibt die Konfigurationsdatei für den im Dispatcher 
  verwendeten Logger an. Die Konfigurationsdatei selbst ist kommentiert, für 
  die einzelnen Optionen bitte  diese einsehen. Wird keine Angabe zur 
  Konfigurationsdatei gemacht, verwendet das Compute-System die Standard-Konfiguration.
  Weitere Informationen finden sich außerdem in der 
  Java API-Do\-ku\-men\-ta\-tion unter java.util.logging.
  Der Dispatcher arbeitet in dem Namespace ``de.unistuttgart.architeuthis.Dispatcher''.
\par {\bf Tipp:} Normalerweise sollten im Betrieb nur Informationen der
  Informationslevel WARNING oder SEVERE geloggt werden, da sonst die Log-Dateien
  zu schnell zu groß werden. Zum Testen empfiehlt sich manchmal, einen
  niedrigeren Level zu wählen, beispielsweise INFO.

\item[-Djava.security.policy=dispatcher.pol]
  Die policy-Datei für den Dispatcher. Diese Datei darf sich nicht in
  einer Jar-Datei befinden; der Pfad muss also relativ oder absolut angegeben
  werden. Siehe dazu das Kapitel \hyperref[sicherh]{Sicherheit}.  

\item[de.unistuttgart.architeuthis.dispatcher.DispatcherImpl]
  Die Klasse zum Starten des Dispatchers.

\item[-c <config-Datei>]
  Optional. Es kann eine Konfigurationsdatei angegeben werden, die die
  restlichen Parameter beinhaltet. Standardmäßig ist ``cmpserv.conf'' eingestellt.
  Falls diese Datei nicht vorhanden ist, werden Standardwerte verwendet.

\item[-port <Port-Nummer>]
  Optional. Setzt die Port-Num\-mer, un\-ter der die RMI-Registry des
  Dispatchers zu erreichen sein wird. Standardmäßig wird 1099 angenommen
  (wie bei jeder RMI-Kommunikation).

\item[-deadtime <Zeit>]   
  Optional. Setzt die Zeit zwischen den Versuchen, Operatives zu finden, die nicht
  mehr reagieren. Eine höhere Zeit verursacht weniger Rechenlast und
  Netzwerk-Verkehr auf dem Dispatcher, jedoch werden dann fehlerhafte Operatives
  evtl. erst sehr spät entdeckt.

\item[-deadtries <Anzahl>]
  Optional. Setzt die Anzahl der Fehler, die sich bei einer Verbindung zu einem Operative
  ereignen dürfen, bis dieser entfernt wird.

\end{description}


\chapter[Benutzung als Operative-Administrator]{Die Benutzung des Systems als
  Operative-Administrator}

\section{Der Operative}
\subsection*{Kurzbeschreibung}
Die Operatives stellen die Rechenleistung des Compute-Systems bereit und
führen die tatsächlichen Berechnungen aus.

\subsection{Voraussetzungen}
Die einzige Voraussetzung zum Betreiben eines Operatives ist ein
installiertes Java-Runtime-Environment der Version 1.3 oder neuer und eine
Netzwerkanbindung. Bei Benutzung von Version 1.3 ist jedoch zu beachten, dass
dann ein nicht-cachender Betrieb nicht möglich ist (siehe
\hyperref[cachen]{nicht-cachender Betrieb}).

\subsection{Benutzung}
Die Benutzung gestaltet sich sehr einfach. Der Operative muss nur
gestartet werden, wobei als Kommandozeilenparameter die RMI-Adresse
des Compute-Managers angegeben werden muss, an den sich der
Operative anmelden soll. Der Operative sollte am Besten mit
nicht zu hoher Priorität im Hintergrund laufen. 
\par {\bf Tipp:} Falls der Compute-Manager dauerhaft läuft, kann der
Operative problemlos beim Rechnerstart im Hintergrund gestartet werden. Das 
Herunterfahren des Rechners beendet den Operative ord\-nungs\-ge\-mäß. Ebenfalls
denkbar ist es, den Operative im Hintergrund des GDM laufen zu lassen. 
\par {\bf Achtung:} Der Dispatcher und der Operative müssen gegenseitig
erreichbar sein.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}
Kommandozeile zum Aufruf des Operatives: \\

{\tt java -Djava.security.policy=operative.pol\\
  -Djava.rmi.server.RMIClassLoaderSpi=\\
  de.unistuttgart.architeuthis.operative.NonCachingRMIClSpi\\
  de.unistuttgart.architeuthis.operative.OperativeImpl\\
  <Adresse> -d}\\

Dabei:
\begin{description}
\item[-Djava.security.policy=operative.pol]
  Lädt die Policy-Datei für den Operative. Diese Datei darf sich nicht in
  einer Jar-Datei befinden; der Pfad muss also relativ oder absolut angegeben
  werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.

\item[-Djava.rmi...NonCachingRMIClSpi]
\label{cachen}
  Lädt einen anderen Service Provider für den RMIClassLoader. Dies bewirkt, dass
  Klassen nicht gecached werden, und somit Probleme, deren Klassen modifiziert
  wurden, wieder mit dem System berechnet werden können. Zur Minimierung des
  Netzwerk-Verkehrs kann diese Option auch entfallen.
\par {\bf Achtung:} Falls diese Option nicht angegeben wird, werden
  Modifikationen in Problem-Klassen nur dann erkannt, falls diese Klassen
  entweder in einem anderen Verzeichnis auf dem Webserver abgelegt werden oder
  der Operative neu gestartet wird. 

\item[de.unistuttgart.architeuthis.operative.OperativeImpl]
  Die Klasse zum Starten des Operatives.

\item[Adresse] 
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}
\item[-d] Optional. Schaltet den Debug-Modus mit zusätzlichen Meldungen
        ein.
\end{description}


\chapter[Benutzung als Endanwender]{Die Benutzung des Systems als Endanwender}

\section{Das eigentliche Problem}
Zu implementieren sind drei Java-Klassen, die im folgenden n"aher erkl"art werden:
\subsection[Problem]{Das Problem - Problem.java} 
Das Problem ist die organisierende Hauptklasse. Es generiert die Teilprobleme, empf"angt die
Teill"osungen und gibt die Gesamtl"osung zur"uck, sobald diese existiert.
Von dem Interface {\tt Problem.java} m"ussen also drei Methoden implementiert werden:
{\scriptsize \verbatiminput{java/Problem.java}}

\subsubsection*{Hinweis:}
Falls das Erstellen von Teilproblemen oder das Verarbeiten von Teillösungen rechenintensiv
ist, ist es ratsam dafür selbst Teilprobleme zu generieren.

\subsection[Teilproblem]{Das Teilproblem - PartialProblem.java}
Das Teilproblem ist das eigentliche Rechenprogramm. Hier wird lediglich die Berechnung
auf dem Operative durchgef"uhrt. Dazu muss nur eine Methode und ein parameterloser 
Konstruktor (wegen der Serialisierbarkeit) implementiert werden:
{\scriptsize \verbatiminput{java/PartialProblem.java}}

\subsection[Teill"osung]{Die Teill"osung - PartialSolution.java}
Die Teill"osung ist das Ergebnis des berechneten Teilproblems. Da sie mit RMI verschickt
wird, muss sie und alle darin verwendeten Klassen {\tt Serializable-Objekte} sein. 
Es ist lediglich ein parameterloser Konstruktor (wegen der Serialisierbarkeit) notwendig:
{\scriptsize \verbatiminput{java/PartialSolution.java}}


\subsection{Wichtige allgemeine Hinweise}
\begin{enumerate}
\item {\bf Achtung:} Selbst durch diese Massnahme kann es zu merkwürdigen
  Effekten kommen, wenn mehrere Probleme gleichzeitig in modifizierter Form
  berechnet werden, oder wenn mehrere Probleme im gleichen Verzeichnis des
  Webservers bereitgestellt werden. Daher sollte am Einfachsten für jedes neue
  Problem auch ein neues Verzeichnis auf dem Webserver angelegt werden. Dann
  treten die oben angedeuteten Probleme nicht mehr auf.
\item Generell ist es empfehlenswert, jedes neue Problem, das auf dem
  Compute-System berechnet werden soll, in einem neuen Verzeichnis auf dem
  Webserver abzulegen.
\item In den Objekten der Klassen {\tt Partial\-Problem} und {\tt Partial\-Solution} dürfen keine
        sta\-ti\-schen Variablen \marginpar{Statische Variablen}
         verwendet werden, da diese beim Versenden der Objekte via RMI nicht
        serialisiert werden. Konstanten (also {\tt static final}-Attribute) dürfen jedoch verwendet
        werden.
\item Kommunikation zwischen {\tt Partial\-Problem}-Objekten wird vom \\{\tt Compute\-System} nicht
        unterstützt
        \marginpar{Kom\-muni\-kation zwischen Teilproblemen}
        und läßt sich auch nicht einfach realisieren. Jedoch kann eine Kommunikation 
        zwischen dem {\tt Pro\-blem}-Ob\-jekt auf dem {\tt Dispatcher} und den 
        {\tt Partial\-Problem}-Objekten realisiert werden, indem der Programmierer der
        {\tt Pro\-blem}-Klas\-se selbst RMI-Methoden vorsieht und jedem generierten {\tt Partial\-Problem}
        eine Referenz auf das {\tt Problem} mitgibt. Diese Möglichkeit wird jedoch auch nicht direkt 
        vom {\tt Compute\-System} unterstützt und funktioniert davon
        unbeeinträchtigt nebenher.
\item Wenn das Ergebnis bereits vorliegt, sollte das {\tt Problem} keine weiteren
  {\tt Partial\-Problem}-Objekte mehr generieren, da solange neue {\tt
  Partial\-Problem}s geliefert werden diese auch berechnet werden, ohne nach der
  Lösung zu fragen. Bei der Ankunft einer berechneten {\tt Par\-tial\-So\-lu\-tion}
  wird jedoch nach dem Endergebnis gefragt.
\item Die Erzeugung und das Zusammensetzen der Teilprobleme sowie das Berechnen der Gesamtl"osung
        sollte, da es auf dem Dispatcher-Rechner ausgef"uhrt wird, nur geringen Rechenaufwand erfordern.
        Falls es mehr Rechenaufwand erfordert, sollten diese T"atigkeiten als eigene Teilprobleme
        vergeben werden.

\end{enumerate}

\subsection[Hilfestellung]{Hilfestellung bei der Implementierung mittels abstrakten Klassen}
Es werden abstrakte Klassen angeboten, die
das Implementieren vereinfachen sollen. Siehe dazu Kapitel 8 \hyperref[abstrakt]{Abstrakte Hilfsklassen}.

\subsection{Bereitstellen der Klassen mittels ClassFileServer}
\label{classfileserver}
Wie schon erwähnt, müssen alle Problem-Klassen auf einem Webserver für alle
Computer des Systems erreichbar sein (also sowohl für Operatives, wie auch für den
Dispatcher). Dabei muss die benutzte Package-Hierarchie als Verzeichnisse nachgebildet werden.
Die Klassen können alternativ auch in einem Jar-File liegen, das ebenfalls die 
Package-Hierarchie nachbildet.\\
Falls kein Webserver zur Verfügung steht, kann der sog. {\tt
  Class\-File\-Server} benutzt werden. Dies ist ein von Sun geschriebener
Mini-Webserver, der nur dazu dient, Klassen an RMI-Applikationen
auszuliefern. Die Benutzung ist sehr einfach. Man starte den
ClassFileServer mit folgender Kommandozeile:\\
{\tt java de.unistuttgart.architeuthis.user.ClassFileServer <port> <root>}\\
Wobei:
\begin{description}
\item[port] Der Port auf dem der Webserver ansprechbar sein soll.
\item[docroot] Das Verzeichnis, das als Wurzel-Verzeichnis für die Dateien des
  Webservers dienen soll.
\end{description}
Danach sind unter {\tt http://<rechnername>:<port>/} alle Dateien und
Verzeichnisse unter {\tt<root>} erreichbar.

\subsubsection*{Achtung!}
Der ClassFileServer gibt beim Starten immer eine Usage-Meldung aus. Man sollte sich dadurch 
nicht irritieren lassen und glauben, man hätte falsche Parameter übergeben.

\section{Der Problem-"Ubermittler}
\subsection*{Kurzbeschreibung}
Der Problem-Übermittler stellt die Schnittstelle zwischen dem Benutzer
und dem Compute-System her und erlaubt es, selbst implementierte
Probleme auf das Compute-System zu übertragen. Dies kann grundsätzlich
auf zwei Arten geschehen:
\begin{itemize}
\item Das Benutzen der Kommandozeilenapplikation {\tt
  Prob\-lem\-Trans\-mit\-ter\-App}
\item Schreiben eines eigenen Programmes unter Benutzung der
Klasse {\tt Pro\-blem\-Trans\-mit\-ter\-Impl}
\end{itemize}
Beide genannten Klassen befinden sich im Package \\{\tt
  de.unistuttgart.architeuthis.user}.

\subsection[Kommandozeilenapplikation]{Die Kommandozeilenapplikation}
Zuerst muss gesagt werden, dass bei Benutzung der
Kommandozeilenapplikation einige Einschränkungen in Kauf genommen
werden müssen. Es können beispielsweise keine Parameter an den
Konstruktor der eigenen Problem-Klasse übergeben werden, so dass alle
Initialisierungswerte bereits fest vorgegeben werden
müssen. Andererseits können damit ohne zusätzlichen Aufwand das Problem
an das Compute-System übermittelt und nebenbei auch die Statistiken
angeschaut werden.

\subsubsection[Kommandozeilenparameter]{Aufruf und
  Kommandozeilenparameter}
Die Kommandozeile zum Aufrufen der ProblemTransmitterApp:\\
{\tt java -Djava.security.policy=transmitter.pol\\
  de.unistuttgart.architeuthis.user.ProblemTransmitterApp -u\\
  <classURL> -r <computesystem> -c <klassenname> -f \\
  <dateiname> -d -n -p}\\

\begin{description}
\item[-Djava.security.policy=transmitter.pol]
  Lädt die Po\-li\-cy-Da\-tei für den Pro\-blem-Über\-mit\-tler. Diese Datei 
  darf sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.user.ProblemTransmitterApp]
  Die Haupt-Klasse des Problem-Übermittlers.
\item[-u <classURL>] Die vollständige Adresse inklusive Unterverzeichnisse
  des Webservers, auf dem die Klassen des Problems bereitgestellt
  werden. Die Adresse muss entweder mit ``/'' enden, falls die Klassen ungepackt 
in der Package-Hierarchie vorliegen, oder mit dem Namen der Jar-Datei, die die Klassen
in der Package-Hierarchie enthält. Man kann auch
  den\hyperref[classfileserver]{ClassFileServer} verwenden.
\item[-r <computesystem>]
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}

\item[-c <klassenname>] Der vollständige Klassenname (inklusive aller Packages)
  der Klasse des Problems, die das Interface Problem implementiert.\\
 {\bf Achtung:} \\
\begin{description} 
\item
Da bei der Übermittlung durch den Problem-Transmitter keine Parameter dem Problem 
übergeben werden können, ist es notwendig, dass das Problem einen parameterlosen
Konstruktor implementiert, der die benötigten Werte initialisiert.
\item
Die Unterverzeichnisse, die durch die Package-Struktur
  entstehen, müssen auf dem Webserver ebenfalls vorhanden
  sein. Beispiel: Die Klasse {\tt MyProblem} aus dem Package {\tt
  mypackage} ist unter der URL {\tt
  http://myserver/mydir/my\-pack\-age/My\-Prob\-lem\-.class} erreichbar. Dann
  muss der Parameter -w den Wert {\tt http://my\-ser\-ver/my\-dir/} erhalten
  und der Parameter -c den Wert {\tt my\-pack\-age.My\-Prob\-lem}.
\end{description}
\item[-f <dateiname>] Der Name der Datei, in dem die Lösung des Problems
  gespeichert werden soll. Die Lösung wird dabei einfach in ihrer
  serialisierten Form in die Datei geschrieben.
\item[-d] Optional. Schaltet zusätliche Debug-Meldungen ein.
\item[-n] Optional. Schaltet die graphischen Elemente aus.
\item[-p] Optional. Schaltet die allgemeine Statistik aus.
\end{description}
\subsubsection*{Achtung!}
Durch Schließen eines der graphischen Statistik-Fenster oder durch Abbrechen
der Applikation mit Strg-C wird der Problem-Übermittler
beendet. Dadurch kann das Compute-System keine Lösung mehr zurücksenden. Dies
beendet aber nicht die Berechnung des Problems auf dem Dispatcher.

\subsection[Problem-spezifisches Übermittlungsprogramm]{Hinweise zum
  Erstellen eines Pro\-blem-spe\-zi\-fi\-schen Über\-mit\-tlungs-Pro\-gramms}
Als Beispiel kann hierzu die Klasse \\
{\tt de.unistuttgart.architeuthis.testenvironment.prim.\-PrimzahlenParallel}
betrachtet werden.

\section{Die Statistik}
\subsection*{Kurzbeschreibung}
Mit der Statistik können Informationen über den Zustand des 
Compute-Systems abgefragt werden. Diese werden graphisch aufbereitet 
ausgegeben.

\subsection{Voraussetzungen}
Die einzige Voraussetzung zum Anzeigen der Statistik ist ein
installiertes Java-Runtime-Environment der Version 1.3 oder neuer und eine
Netzwerkanbindung oder lokal auf dem Dispatcher-Rechner. Für die graphische Statistik-Ausgabe ist eine funktionierende graphische Oberfläche.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}
Aufruf der graphischen Version:\\
{\tt java -Djava.security.policy=statisticreader.pol\\
de.unistuttgart.architeuthis.user.StatisticReaderFrame <computeSystem>}
Aufruf der Konsole-Version:\\
{\tt java -Djava.security.policy=statisticreader.pol\\
de.unistuttgart.architeuthis.user.StatisticReader <computeSystem>}

\begin{description}
\item[-Djava.security.policy=statisticreader.pol]
  Lädt die Po\-li\-cy-Da\-tei für die Statistik-Anzeige. Diese Datei 
  darf sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.user.StatisticReaderFrame]
  Die Haupt-Klasse der graphischen Statistik-Anzeige.
\item[de.unistuttgart.architeuthis.user.StatisticReader]
  Die Haupt-Klasse der Konsole-Statistik-Anzeige.
\item{<computeSystem>}
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}


\end{description}

\section{Die Testumgebung}
\subsection*{Kurzbeschreibung}
Das Programm dient zum Vergleich zwischen der Berechnung eines Problems auf
einem einzelnen Computer und der Berechnung auf dem Compute-System. Es gibt jeweils
die L"osung bei beiden Berechnungen aus, sowie die gebrauchte Zeit und speichert
die L"osung von der verteilten Berechnung in einer anzugebenen Datei. 

\subsection{Lokale Berechnung}
Die Berechnung auf einem einzelnen Computer ist so realisiert, dass dem Problem mitgeteilt
wird, dass nur ein Operative zur Verf"ugung steht. Ob dann nur ein
Teilproblem generiert wird h"angt von der Implementierung des Problems ab.
Die generierten Teilprobleme werden jedenfalls nur von einem Operative
seriell berechnet und dann zur Gesamtl"osung zusammengefasst.

\subsection{Verteilte Berechnung}
Bei der verteilte Berechnung wird das Problem dem Compute-System mittels
dem Problem-"Ubermittler an ein Compute-System "ubergeben und berechnet.

\subsection[Kommandozeilenparameter]{Aufruf und
  Kommandozeilenparameter}
Die Kommandozeile zum Aufrufen der Testumgebung:\\
{\tt java -Djava.security.policy=transmitter.pol\\
  de.unistuttgart.architeuthis.testenvironment.Testumgebung\\
  -u <classURL> -r <computesystem>\\
   -c <klassenname> -f <dateiname>}\\
Dabei:
\begin{description}
\item[-Djava.security.policy=transmitter.pol]
  Die für die Testumgebung zu benutzende policy-Datei. Diese Datei darf
  sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe Kapitel \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.testenvironment.Testumgebung]
  Die Haupt-Klasse der Testumgebung.
\item[-u <classURL>] Die vollständige Adresse inklusive Unterverzeichnisse
  des Webservers, auf dem die Klassen des Problems bereitgestellt
  werden. Man kann auch den\hyperref[classfileserver]{ClassFileServer} verwenden.
\item[-r <computesystem>] 
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}
\item[-c <klassenname>] Der vollständige Klassenname (inklusive aller Packages)
  der Klasse des Problems, die das Interface Problem implementiert.\\
 {\bf Achtung:} Die Unterverzeichnisse, die durch die Package-Struktur
  entstehen, müssen auf dem Webserver ebenfalls vorhanden
  sein. Beispiel: Die Klasse {\tt MyProblem} aus dem Package {\tt
  mypackage} ist unter der URL {\tt
  http://myserver/mydir/my\-pack\-age/My\-Prob\-lem\-.class} erreichbar. Dann
  muss der Parameter -w den Wert {\tt http://my\-ser\-ver/my\-dir/} erhalten
  und der Parameter -c den Wert {\tt my\-pack\-age.My\-Prob\-lem}.
\item[-f <dateiname>] Der Name der Datei, in dem die Lösung des Problems
  gespeichert werden soll. Die Lösung wird dabei einfach in ihrer
  serialisierten Form in die Datei geschrieben.
\end{description}

\chapter{Sicherheit}
\label{sicherh}
\section{Wichtiger Hinweis}
Bei Benutzung des Compute-Systems muss man sich dringend vor Augen führen, dass
man explizit anderen Benutzern erlaubt, Programme auf dem eigenen 
Dispatcher-Rechner und den Operative-Rechnern auszuführen. Mit der folgenden 
Massnahme ist es jedoch anderen Benutzern nicht möglich, schädlichen Code 
auszuführen. Dies gilt natürlich nur dann, falls die policy-Dateien und die 
Security-Manager korrekt eingebunden werden.

\section{Benutzung der policy-Dateien}
Durch die Angabe von {\tt -Djava.security.policy=<policy-Datei>} wird die 
Java Virtual Machine dazu veranlasst, den verwendeten Security-Manager 
entsprechend den Regeln in der policy-Datei zu konfigurieren. Die 
policy-Datei muss dazu frei zugänglich sein, darf sich also nicht in 
einer Jar-Datei mit den Klassen befinden. Deshalb ist der Pfad relativ oder absolut anzugeben.

\section{Die policy-Dateien}
Um eine möglichst große Sicherheit zu gewährleisten, werden in allen Teilen des
Systems Security-Manager verwendet (für nähere Informationen siehe bitte
Java-API-Dokumentation). Damit die einzelnen Programm-Teile dann nur die
nötigsten Rechte auf den ausführenden Computern erhalten, wurden die
policy-Dateien entwickelt. Außerdem bietet dieses Konzept den Vorteil, dass
jeder Benutzer in Klartext (zumindest beinahe) die Rechte einsehen kann, die
jedes einzelne Java-Programm hat, indem er direkt die policy-Dateien editiert.
Welche policy-Dateien im Einzelnen zu verwenden sind, findet sich bei den
Kapiteln zu den jeweiligen Programmteilen.
\par Wichtige Einschränkungen in den policy-Dateien sind:
\begin{itemize}
\item Kein Zugriff auf das Dateisystem (außer Problem-Übermittler).
\item Kein Zugriff auf die Systemeigenschaften.
\item Kein Zugriff auf die Security-Manager.
\end{itemize}
\par Erlaubt ist standard-mäßig jedoch:
\begin{itemize}
\item Jeglicher Netzwerkverkehr.
\end{itemize}
Für das Benutzen eines neuen RMIClassLoaderSpi für den Dispatcher und
eventuell für den Operative wird zusätzlich benötigt:
\begin{itemize}
\item Erstellen und Benutzen von eigenen ClassLoadern.
\item Zugriff auf die RMI-Codebase.
\item Zugriff auf Sockets, um den Socket zum Laden von Klassen zu setzen.
\end{itemize}
\par Die weiteren Einstellungen können direkt aus den policy-Dateien abgelesen
werden. Die oben genannten Einschränkungen können natürlich aufgehoben werden,
falls dies für ein Problem von Bedeutung ist. Möglich ist z.B. auch, nur
gewissen signierten Java-Klassen weitere Rechte zu geben. Dazu sei jedoch auf
die Dokumentation von Sun verwiesen.

\subsection{Höhere Sicherheit}
Die policy-Dateien können an einigen Stellen weiter eingeschränkt werden. So kann
auf dem Operative beispielsweise nur Netzwerk-Verkehr zu einem bestimmten
Dispatcher erlaubt werden. Um diese weiteren Einstellungen vorzunehmen wird 
jedoch empfohlen, die policy-Dateien direkt zu editieren, und die dortigen 
Kommentare zu lesen.

\subsection{Sicherheit für den Benutzer}
Da sich beliebige Operatives an das Compute-System zur Berechnung von
Teilproblemen anmelden dürfen, wäre es auch denkbar, dass die Ergebnisse dadurch
verfälscht werden, dass gehackte Operatives mutwillig falsche Ergebnisse
zurückliefern. Dies läßt sich beispielsweise dadurch verhindern, dass man in der
policy-Datei des Dispatchers nur gewissen Rechnern das Betreiben eines
Operatives erlaubt, indem man zu anderen Rechnern die Netzwerkverbindungen
untersagt. Beispiele dazu finden sich direkt in der Datei {\tt dispatcher.pol} oder
in der Java API Dokumentation unter {\tt java.net.Socket\-Permission}.


\chapter{Performance}
\section{Einführung}
In diesem Kapitel sind die Ergebnisse einiger Untersuchungen festgehalten, denen
das Compute-System unterzogen wurde, um herauszufinden, wie hoch der
Geschwindigkeitszuwachs bei mehreren Operatives ist, aber auch, wie hoch
der Zeitverlust ist, der sich durch das Verteilen der Probleme ergibt.

\section{Testkonfiguration}
Die Tests wurden in einem Computer-Pool durchgeführt, der während der
Durchführung der Test auch von anderen Leuten benutzt wurde. Alle genannten
Zeiten verstehen sich, falls nicht anders bezeichnet, in Sekunden und sind
gerundete Mittelwerte mehrerer Messreihen eines bereits benutzten
Compute-Systems (siehe dazu ``Der erste Start'').

\subsection{Dispatcher}
  \begin{itemize}
  \item Dual-Athlon 1800+
  \item 1 GB RAM
  \item Red Hat Linux 9
  \item Sun JRE Version 1.4.2
  \end{itemize}
\subsection{Operatives}
  \begin{itemize}
  \item Pentium III 600 MHz
  \item 256 MB RAM
  \item Red Hat Linux 7.3
  \item Sun JRE Version 1.4.0
  \end{itemize}

\subsection{Testprobleme}
\subsubsection{Prim-Problem}
Für das Prim-Problem ist die Aufgabenstellung: Berechne die 2000000te Primzahl.
Verwendet wurde die Klasse {\tt PrimTest} aus dem Package {\tt
  de.unistuttgart.architeuthis.testenvironment.prim}.

\subsubsection{Caching-Problem}
Hier ist die Aufgabe: Berechne die 2000000te Primzahl. Außerdem werden jedoch
drei Klassen zusätzlich vom Webserver geladen, um zu testen, wie stark sich
das Caching der Klassen auf die Performance auswirkt. Verwendet wurde die Klasse
{\tt CachingTestProblem} in {\tt de.unistuttgart.architeuthis.\-testenvironment.caching}.

\subsection{Referenzwerte}
Folgender Wert ist als Referenzwert zu betrachten: Die lokale Berechnung des
Prim-Problems auf einem Operative-Rechner benötigt 307,6s. Dies definiert
einem Speed-Up von 1. Wenn man das Prim-Problem auf einem Rechner verteilt (also
mit einem Dispatcher und einem Operative) berechnet, dann ergibt sich
eine Dauer von 413,8s, also ein ``Speed-Up'' von 0,74.
\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l l}
  Beschreibung & Dauer in Sekunden & Speed-Up\\ \hline
  Berechnung mit lokaler Klasse & 307,6 & 1\\
  Verteilte Berechnung auf nur einem Rechner & 391,2 & 0,79\\
  \end{tabular}
  \caption{Referenzwerte}
\end{table*}

\section{Testergebnisse}
\subsection{Verschiedene Anzahlen von Operatives}
\subsubsection{Aufgabenstellung}
Dieser Test soll Aufschluss über die effektive Geschwindigkeitssteigerung geben,
die bei Verwendung mehrerer Operatives zu erwarten ist. Gestellt wurde das
Prim-Problem.

\subsubsection{Ergebnisse}

\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l l}
  Anzahl Operatives & Gesamtdauer & Speed-Up\\
  \hline
  25 & 20,9 & 14,7 \\
  20 & 25,0 & 12,3\\
  15 & 33,2 & 9,3\\
  10 & 44,7 & 6,9\\
  5  & 84,2 & 3,6\\
  3  &133,6 & 2,3\\
  1  &349,2 & 0,88\\
  \end{tabular}
  \caption{Prim-Problem ohne Caching auf Operativeseite}
  
\end{table*}

\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l l}
  Anzahl Operatives & Gesamtdauer & Speed-Up\\
  \hline
  25 & 20,9 & 14,7 \\
  20 & 24,8 & 12,4\\
  15 & 32,6 & 9,4\\
  10 & 46,6 & 6,6\\
  5  & 86,4 & 3,6\\
  3  &138,2 & 2,2\\
  1  &360,9 & 0,85\\
  \end{tabular}
  \caption{Prim-Problem mit aktiviertem Caching auf Operativeseite}
\end{table*}

Aus den Messwerten ist zu entnehmen, dass die Geschwindigkeit nahezu linear mit
der Anzahl der Operatives skaliert.

\subsection{Einfluss des Caching}

\subsubsection{Aufgabenstellung}
Wie oben bereits ersichtlich ist, beeinflusst das Caching bei großen
Rechenzeiten pro Teilproblem und wenig zu ladenden Klassen die Geschwindikeit
kaum. Um einen Unterschied zu messen, wurde das Caching-Problem gestellt. Bei
diesem Test wurden 15 Operatives verwendet.

\subsubsection{Ergebnisse}
\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l}
  Status & Dauer in Millisekunden\\ \hline
  Caching aktiviert & 1182\\
  Caching deaktiviert & 2239\\
  \end{tabular}
  \caption{Berechnung des Caching-Problems mit 15 Operatives}
\end{table*}

Man sieht, dass erst bei sehr kurzen Berechnungszeiten der Teilprobleme das
Caching einen Geschwindigkeitsvorteil bringt, da dann das Laden der Klassen
überproportional viel Zeit benötigt.

\subsubsection{Aufgabenstellung}
Ein weiterer Test zum Caching bestand darin, 3 Probleme, die ebenfalls die 
2000000te Primzahl berechnen, zu vergleichen. Zusätzlich zum Prim- und zum
Caching-Problem wurde ein MyInteger-Problem geschrieben, dass die Lösung in
eine eigene Klasse, die ebenfalls vom Webserver geladen werden muss, schreibt.

\subsubsection{Ergebnisse}
\begin{table*}[htbp]
\centering
\begin{tabular}{l l l l}
Anzahl der Operatives & Prim-Problem & Caching-Problem & MyInteger-Problem \\
\hline
25 & 17  & 18  & 17  \\
20 & 21  & 22  & 23  \\
15 & 27  & 27  & 27  \\
10 & 41  & 41  & 42  \\
5  & 82  & 82  & 82  \\
3  & 133 & 132 & 131 \\
1  & 346 & 346 & 346 \\
\end{tabular}
\caption{Unterschiede zwischen den Problemen mit Cache}
\end{table*}

\begin{table*}[htbp]
\centering
\begin{tabular}{l l l l}
Anzahl der Operatives & Prim-Problem & Caching-Problem & MyInteger-Problem \\
\hline
25 & 22  & 25  & 22  \\
20 & 23  & 26  & 27  \\
15 & 31  & 32  & 32  \\
10 & 43  & 43  & 43  \\
5  & 85  & 82  & 81  \\
3  & 133 & 133 & 133 \\
1  & 350 & 345 & 346 \\
\end{tabular}
\caption{Unterschiede zwischen den Problemen ohne Cache}
\end{table*}

\subsubsection{Speedup}
Als Referenzwerte dienten:
\begin{table*}[htbp]
\centering
\begin{tabular}{l | l}
Prim-Problem & 304,6 \\
Caching-Problem & 305,2 \\
MyInteger-Problem & 310,3 \\
\end{tabular}
\end{table*}

Das ergibt einen Speedup von:
\begin{table*}[htbp]
\centering
\begin{tabular}{l l l}
Anzahl der Operatives & Prim-Problem & Prim-Problem \\
& mit Cache & ohne Cache \\ \hline
25 & 17,92 & 13,85 \\
20 & 14,51 & 13,24 \\
15 & 11,28 & 9,83  \\
10 & 7,43  & 7,08  \\
5  & 3,72  & 3,58  \\
3  & 2,29  & 2,29  \\
1  & 0,88  & 0,87  \\
\end{tabular}
\end{table*}

\begin{table*}[htbp]
\centering
\begin{tabular}{l l l}
Anzahl der Operatives& Caching-Problem & 
Caching-Problem \\
& mit Cache & ohne Cache \\ \hline
25 & 17,24 & 12,41\\
20 & 14,10 & 11,93\\
15 & 11,49 & 9,70 \\
10 & 7,57  & 7,22 \\
5  & 3,78  & 3,78 \\
3  & 2,35  & 2,33 \\
1  & 0,90  & 0,90 \\
\end{tabular}
\end{table*}

\begin{table*}[htbp]
\centering
\begin{tabular}{l l l}
Anzahl der Operatives & MyInteger-Problem & MyInteger-Problem \\
& mit Cache & ohne Cache\\ \hline
25 & 17,95 & 13,87 \\
20 & 13,27 & 11,30 \\
15 & 11,30 & 9,54  \\
10 & 7,27  & 7,10  \\
5  & 3,72  & 3,77  \\
3  & 2,33  & 2,29  \\
1  & 0,88  & 0,88  \\
\end{tabular}
\end{table*}

\subsection{Der erste Start}

\subsubsection{Aufgabenstellung}
Während der Tests stellten wir fest, dass aufgrund einiger Eigenarten des
RMI-Systems die erste Eingabe eines Problems in das Compute-Systems stets länger
dauert als die folgenden Eingaben (selbst bei abgeschaltetem Caching). Dies
hängt vor allem mit der Benutzung der Socket-Verbindungen zusammen, da diese
unter RMI wiederverwendet werden, sobald einmal eine Verbindung hergestellt
wurde. Um diesen Einfluss zu testen, wurden die folgenden Testreihen
durchgeführt.

\subsubsection{Ergebnisse}
\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l}
  Status & Dauer in Millisekunden\\ \hline
  Erster Start, Caching aktiviert & 7197\\
  Weitere Starts, Caching aktiviert & 1166\\ \hline
  Erster Start, Caching deaktiviert & 7457\\
  Weitere Starts, Caching deaktiviert & 2239\\
  \end{tabular}
  \caption{Berechnung des Caching-Problems mit 15 Operatives}
\end{table*}

\begin{table*}[htbp]
  \centering
  \begin{tabular}{l l}
  Status & Dauer in Millisekunden\\ \hline
  Erster Start, Caching aktiviert & 31,0\\
  Weitere Starts, Caching aktiviert & 20,4\\ \hline
  Erster Start, Caching deaktiviert & 29,3\\
  Weitere Starts, Caching deaktiviert & 21,2\\
  \end{tabular}
  \caption{Berechnung des Prim-Problems mit 25 Operatives}
\end{table*}


\chapter{Abstrakte Hilfsklassen}\label{abstrakt}
Alle abstrakten Hilfsklassen sollen nur eine Hilfestellung sein, (einfache) Probleme
schnell zu implementieren.

Die abstrakten Klassen bieten drei Funktionen an:

\begin{enumerate}
\item  Sie liefern oder ordnen die Teillösungen in der Reihenfolge der
       erzeugten Teilprobleme. Diese Funktion ist bei allen drei abstrakten
       Klassen vorhanden.
\item  Sie fragen die Teilprobleme nicht einzeln sondern als Menge ab und
       liefern eine Menge der zughörigen Teillösungen. Diese Funktionalität
       ist nur bei \texttt{AbstractFixedSizeProblem} und\\
       \texttt{AbstractFixedSizePriorityProblem} vorhanden.
\item  Sie bearbeiten die Teilprobleme in einer durch Prioritäten
       vorgegebenen Reihenfolge. Diese Funktionalität ist nur bei\\
       \texttt{AbstractFixedSizePriorityProblem} vorhanden.
\end{enumerate}

Die Klassen sind nachfolgend einzeln beschrieben.


\section{AbstractOrderedProblem.java}
Diese Klasse sorgt dafür, das die Teillösungen in der gleichen Reihenfolge
geliefert werden, in der die zugehörigen Teilprobleme erzeugt wurden. Eine
onkrete Unterklasse muß dazu die beiden folgenden Methoden implementieren:

\begin{itemize}
\item createPartialProblem, die ein neues Teilprobem liefert. Als Parameter
  wird ihr die empfohlene Anzahl insgesamt zu erzeugender Teilprobleme
  übergeben.
\item receivePartialSolution, die jeweils eine Teillösung übergibt und als
  Rückabewert die Gesamtlösung erwartet, falls diese schon vorhanden ist,
  oder anderenfalls den Wert \texttt{null}.
\end{itemize}

Nachfolgend ist der komplette Quelltext angegeben.

{\scriptsize \verbatiminput{java/AbstractOrderedProblem.java}}


\section{AbstractFixedSizeProblem.java}
Diese Klasse eignet sich für Probleme, die am Anfang schon alle Teilprobleme 
erstellen können, die auch alle für die Lösung erforderlich sind. Die Anzahl
kann  von der vom Dispatcher vorgeschlagenen Anzahl abhängen oder konstant
sein. Die Arbeit zum einzelnen Ausgeben der Teilprobleme, wie es der Dispatcher
fordert, und die Arbeit zum Sammeln der Teillösungen werden übernommen. D.h.
der Benutzer muss nur noch zwei Methoden implementieren:
\begin{itemize}
\item createPartialProblems, die bei der ersten Anfrage für ein Teilproblem
  aufgerufen wird und ein Array aller nötigen Teilprobleme erstellt. 
\item createSolution, die aufgerufen wird, wenn alle Lösungen eingegangen sind.
  Es muss auf jeden Fall eine Lösung erstellt werden können, ansonsten ist
  dieses Problem fehlerhaft und wird entfernt. Die Teillösungen im
  Übergabeparameter sind in der Reihenfolge der entsprechend Teilprobleme
  geordnet.
\end{itemize}

Nachfolgend ist der komplette Quelltext angegeben.

{\scriptsize \verbatiminput{java/AbstractFixedSizeProblem.java}}


\section{AbstractFixedSizePriorityProblem.java}
Diese Klasse benutzt die Klasse \texttt{AbstractFixedSizePriorityPartialProblem}.\\
Diese beiden Klassen eignen sich für Probleme, die am Anfang schon 
alle Teilprobleme erstellen können und diese in einer durch Priorisierung gekennzeichneten
Reihenfolge berechnet werden sollen. Die Kennzeichnung findet für jedes Teilproblem
individuell statt, indem dessen Priorität durch den Konstruktor gesetzt wird. Dabei bedeuten
höhere Werte eine höhere Priorität, d.h.\ dass dieses Teilproblem früher
berechnet wird.\\
Die Arbeit zum einzelnen Ausgeben der Teilprobleme in dieser Reihenfolge und 
das Sammeln der Teillösungen wird übernommen. Außerdem werden die Teillösungen
wieder in die Reihenfolge gebracht, wie ihre Teilprobleme erstellt wurden.
Der Benutzer muss folgende zwei Methoden implementieren, wobei die
Teilprobleme von \texttt{AbstractFixedSizePriorityPartialProblem} erben müssen.

\begin{itemize}
\item createPartialProblems, die bei der ersten Anfrage für ein Teilproblem aufgerufen wird und
  eine Liste aller nötigen Teilprobleme, deren Priorität gesetzt wurde, erstellt. 
\item createSolution, die aufgerufen wird, wenn alle Lösungen eingegangen sind. Es muss auf 
  jeden Fall eine Lösung erstellt werden können, ansonsten ist dieses Problem fehlerhaft und wird
  entfernt.
\end{itemize}

Bei der Implementierung des Teilproblems ist zu beachten, dass die Methode zur
Berechnung \texttt{compute} heißt (wie es durch das Interface
\texttt{PartialProblem} vorgegeben ist).

Nachfolgend ist der komplette Quelltext der beiden Klassen angegeben.

{\scriptsize \verbatiminput{java/AbstractFixedSizePriorityProblem.java}}
{\scriptsize \verbatiminput{java/AbstractFixedSizePriorityPartialProblem.java}}

