%% Realease 1.0 dieser Software wurde am Institut für Intelligente Systeme der
%% Universität Stuttgart (http://www.informatik.uni-stuttgart.de/ifi/is/) unter
%% Leitung von Dietmar Lippold (dietmar.lippold@informatik.uni-stuttgart.de)
%% entwickelt.

\chapter[Benutzung als Dispatcher -Administrator]{Die Benutzung des Systems als
  Dispatcher-Administrator}

\section{Der Dispatcher}
\subsection*{Kurzbeschreibung}
Der Dispatcher besteht aus drei Komponenten: Dem Compute-Manager,
dem Problem-Manager und der Statistik. Er ist das Herzst"uck des 
Compute-Systems. 

\subsection{Voraussetzungen}
Benötigt wird zunächst ein funktionierendes Java Runtime Environment, Version
1.4 oder neuer. Es ist eine Netzwerkanbindung n"otig, damit eine Kommunikation
zu den Operatives geschaffen werden kann. Besondere Hardware-Anforderungen
werden nicht gestellt, ein Rechner mit 600 MHz und 256MB RAM kann problemlos 
als Dispatcher für über 30 Operatives dienen.

\subsection{Benutzung}
Um den Dispatcher benutzen zu können, muss er auf einem von allen
Operatives erreichbaren Computer gestartet werden. Dieser Computer muss
auch für Anfragen von den Computern offen sein, die später Probleme auf den
Dispatcher übertragen wollen.
Wie später beim Operative gilt auch hier: Am besten läuft der
Dispatcher mit angepaßter Priorität im Hintergrund.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}
Kommandozeile zum Starten des Dispatchers (alles in einer Zeile, die
Zeilenumbrüche wurden nur zur besseren Übersicht eingefügt):\\

{\tt java -Djava.rmi.server.RMIClassLoaderSpi=\\
  de.unistuttgart.architeuthis.dispatcher.problemmanaging.CacheFlushingRMIClSpi\\
  -Djava.util.logging.config.file=logging.properties\\
  -Djava.security.policy=dispatcher.pol\\
  de.unistuttgart.architeuthis.dispatcher.DispatcherImpl\\
  -c <config-Datei> -port <Port-Nummer>\\
  -deadtime <Zeit> -deadtries <Anzahl>}\\

Dabei: 
\begin{description}
\item[-Djava.rmi...CacheFlushingRMIClSp] Optional. Hiermit werden die Klassen 
  von Problemen nur gecached, solange das Problem in Berechnung ist,
  sobald die Lösung dem Benutzer zurückübermittelt wurde, werden die
  dazugehörigen Klassen aus dem Cache gelöscht. Damit können Probleme,
  deren Klassen modifiziert wurden, dem Compute-System wieder zum 
  Berechnen übergeben werden. Normalerweise würde das Java-eigene
  cachen von Klassen dies verhindern.
  \par {\bf Achtung:} Selbst durch diese Massnahme kann es zu merkwürdigen
  Effekten kommen (z.B. ClassCast-Exception), wenn mehrere Probleme
  gleichzeitig in modifizierter Form berechnet werden, oder wenn
  mehrere Probleme im gleichen Verzeichnis des Webservers bereitgestellt
  werden. Es ist auch keine mehrfache Berechnung eine einzelnen Problems
  gleichzeitig möglich. Daher sollte am Einfachsten für jedes neue
  Problem auch ein neues Verzeichnis auf dem Webserver angelegt werden. Dann
  treten die oben angedeuteten Probleme nicht mehr auf.

\item[-Djava.util.logging.config.file=logging.properties]
  Optional. Gibt die Konfigurationsdatei für den im Dispatcher 
  verwendeten Logger an. Die Konfigurationsdatei selbst ist kommentiert, für 
  die einzelnen Optionen bitte  diese einsehen. Wird keine Angabe zur 
  Konfigurationsdatei gemacht, verwendet das Compute-System die Standard-Konfiguration.
  Weitere Informationen finden sich außerdem in der 
  Java API-Do\-ku\-men\-ta\-tion unter java.util.logging.
  Der Dispatcher arbeitet in dem Namespace\\
  ``de.unistuttgart.architeuthis.Dispatcher''.
\par {\bf Tipp:} Normalerweise sollten im Betrieb nur Informationen der
  Informationslevel WARNING oder SEVERE geloggt werden, da sonst die Log-Dateien
  zu schnell zu groß werden. Zum Testen empfiehlt sich manchmal, einen
  niedrigeren Level zu wählen, beispielsweise INFO.

\item[-Djava.security.policy=dispatcher.pol]
  Die policy-Datei für den Dispatcher. Diese Datei darf sich nicht in
  einer Jar-Datei befinden; der Pfad muss also relativ oder absolut angegeben
  werden. Siehe dazu das Kapitel \hyperref[sicherh]{Sicherheit}.  

\item[de.unistuttgart.architeuthis.dispatcher.DispatcherImpl]
  Die Klasse zum Starten des Dispatchers.

\item[-c <config-Datei>]
  Optional. Es kann eine Konfigurationsdatei angegeben werden, die die
  restlichen Parameter beinhaltet. Standardmäßig ist ``cmpserv.conf'' eingestellt.
  Falls diese Datei nicht vorhanden ist, werden Standardwerte verwendet.

\item[-port <Port-Nummer>]
  Optional. Setzt die Port-Num\-mer, un\-ter der die RMI-Registry des
  Dispatchers zu erreichen sein wird. Standardmäßig wird 1099 angenommen
  (wie bei jeder RMI-Kommunikation).

\item[-deadtime <Zeit>]   
  Optional. Setzt die Zeit zwischen den Versuchen, Operatives zu finden, die nicht
  mehr reagieren. Eine höhere Zeit verursacht weniger Rechenlast und
  Netzwerk-Verkehr auf dem Dispatcher, jedoch werden dann fehlerhafte Operatives
  evtl. erst sehr spät entdeckt.

\item[-deadtries <Anzahl>]
  Optional. Setzt die Anzahl der Fehler, die sich bei einer Verbindung zu einem Operative
  ereignen dürfen, bis dieser entfernt wird.

\end{description}


\chapter[Benutzung als Operative-Administrator]{Die Benutzung des Systems als
  Operative-Administrator}

\section{Der Operative}
\subsection*{Kurzbeschreibung}
Die Operatives stellen die Rechenleistung des Compute-Systems bereit und
führen die tatsächlichen Berechnungen aus.

\subsection{Voraussetzungen}
Die einzige Voraussetzung zum Betreiben eines Operatives ist ein
installiertes Java-Runtime-Environment der Version 1.3 oder neuer und eine
Netzwerkanbindung. Bei Benutzung von Version 1.3 ist jedoch zu beachten, dass
dann ein nicht-cachender Betrieb nicht möglich ist (siehe
\hyperref[cachen]{nicht-cachender Betrieb}).

\subsection{Benutzung}
Die Benutzung gestaltet sich sehr einfach. Der Operative muss nur
gestartet werden, wobei als Kommandozeilenparameter die RMI-Adresse
des Compute-Managers angegeben werden muss, an den sich der
Operative anmelden soll. Der Operative sollte am Besten mit
nicht zu hoher Priorität im Hintergrund laufen. 
\par {\bf Tipp:} Falls der Compute-Manager dauerhaft läuft, kann der
Operative problemlos beim Rechnerstart im Hintergrund gestartet werden. Das 
Herunterfahren des Rechners beendet den Operative ord\-nungs\-ge\-mäß. Ebenfalls
denkbar ist es, den Operative im Hintergrund des GDM laufen zu lassen. 
\par {\bf Achtung:} Der Dispatcher und der Operative müssen gegenseitig
erreichbar sein.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}
Kommandozeile zum Aufruf des Operatives: \\

{\tt java -Djava.security.policy=operative.pol\\
  -Djava.rmi.server.RMIClassLoaderSpi=\\
  de.unistuttgart.architeuthis.operative.NonCachingRMIClSpi\\
  de.unistuttgart.architeuthis.operative.OperativeImpl\\
  <Adresse> -d}\\

Dabei:
\begin{description}
\item[-Djava.security.policy=operative.pol]
  Lädt die Policy-Datei für den Operative. Diese Datei darf sich nicht in
  einer Jar-Datei befinden; der Pfad muss also relativ oder absolut angegeben
  werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.

\item[-Djava.rmi...NonCachingRMIClSpi]
\label{cachen}
  Lädt einen anderen Service Provider für den RMIClassLoader. Dies bewirkt, dass
  Klassen nicht gecached werden, und somit Probleme, deren Klassen modifiziert
  wurden, wieder mit dem System berechnet werden können. Zur Minimierung des
  Netzwerk-Verkehrs kann diese Option auch entfallen.
\par {\bf Achtung:} Falls diese Option nicht angegeben wird, werden
  Modifikationen in Problem-Klassen nur dann erkannt, falls diese Klassen
  entweder in einem anderen Verzeichnis auf dem Webserver abgelegt werden oder
  der Operative neu gestartet wird. Wenn die Option angegeben wird, dürfen
  die class-Dateien nicht geändert werden, während das Problem berechnet wird.

\item[de.unistuttgart.architeuthis.operative.OperativeImpl]
  Die Klasse zum Starten des Operatives.

\item[Adresse] 
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}
\item[-d] Optional. Schaltet den Debug-Modus mit zusätzlichen Meldungen
        ein.
\end{description}


\chapter[Benutzung als Endanwender]{Die Benutzung des Systems als Endanwender}

\section{Das eigentliche Problem}
Zu implementieren sind drei Java-Klassen, die im folgenden n"aher erkl"art werden:
\subsection[Problem]{Das Problem - Problem.java} 
Das Problem ist die organisierende Hauptklasse. Es generiert die Teilprobleme, empf"angt die
Teill"osungen und gibt die Gesamtl"osung zur"uck, sobald diese existiert.
Von dem Interface {\tt Problem.java} m"ussen also drei Methoden implementiert werden:
{\scriptsize \verbatiminput{java/Problem.java}}

\subsubsection*{Hinweis:}
Falls das Erstellen von Teilproblemen oder das Verarbeiten von Teillösungen rechenintensiv
ist, ist es ratsam dafür selbst Teilprobleme zu generieren.

\subsection[Teilproblem]{Das Teilproblem - PartialProblem.java}
Das Teilproblem ist das eigentliche Rechenprogramm. Hier wird lediglich die Berechnung
auf dem Operative durchgef"uhrt. Dazu muss nur eine Methode und ein parameterloser 
Konstruktor (wegen der Serialisierbarkeit) implementiert werden:
{\scriptsize \verbatiminput{java/PartialProblem.java}}

\subsection[Teill"osung]{Die Teill"osung - PartialSolution.java}
Die Teill"osung ist das Ergebnis des berechneten Teilproblems. Da sie mit RMI verschickt
wird, muss sie und alle darin verwendeten Klassen {\tt Serializable-Objekte} sein. 
Es ist lediglich ein parameterloser Konstruktor (wegen der Serialisierbarkeit) notwendig:
{\scriptsize \verbatiminput{java/PartialSolution.java}}

\subsection{Wichtige allgemeine Hinweise}

\begin{enumerate}
\item Generell ist es empfehlenswert, jedes neue Problem, das auf dem
      Compute-System berechnet werden soll, in einem neuen Verzeichnis auf
      dem Webserver abzulegen.

\item In den Objekten der Klassen {\tt Partial\-Problem} und
      {\tt Partial\-Solution} dürfen keine sta\-ti\-schen Variablen
      \marginpar{Statische Variablen} verwendet werden, da diese beim
      Versenden der Objekte via RMI nicht serialisiert werden. Konstanten
      (also {\tt static final}-Attribute) dürfen jedoch verwendet werden.

\item Kommunikation zwischen {\tt Partial\-Problem}-Objekten wird vom \\
      {\tt Compute\-System} nicht unterstützt
      \marginpar{Kom\-muni\-kation zwischen Teilproblemen} und läßt sich
      auch nicht einfach realisieren. Jedoch kann eine Kommunikation 
      zwischen dem {\tt Pro\-blem}-Ob\-jekt auf dem {\tt Dispatcher} und
      den  {\tt Partial\-Problem}-Objekten realisiert werden, indem der
      Programmierer der {\tt Pro\-blem}-Klas\-se selbst RMI-Methoden
      vorsieht und jedem generierten {\tt Partial\-Problem} eine Referenz
      auf das {\tt Problem} mitgibt. Diese Möglichkeit wird jedoch auch
      nicht direkt  vom {\tt Compute\-System} unterstützt und funktioniert
      davon unbeeinträchtigt nebenher.

\item Wenn das Ergebnis bereits vorliegt, sollte das {\tt Problem} keine
      weiteren {\tt Partial\-Problem}-Objekte mehr generieren, da solange
      neue {\tt Partial\-Problem}s geliefert werden diese auch berechnet
      werden, ohne nach der Lösung zu fragen. Bei der Ankunft einer
      berechneten {\tt Par\-tial\-So\-lu\-tion} wird jedoch nach dem
      Endergebnis gefragt.

\item Die Erzeugung und das Zusammensetzen der Teilprobleme sowie das
      Berechnen der Gesamtl"osung sollte, da es auf dem Dispatcher-Rechner
      ausgef"uhrt wird, nur geringen Rechenaufwand erfordern. Falls es mehr
      Rechenaufwand erfordert, sollten diese T"atigkeiten als eigene
      Teilprobleme vergeben werden.
\end{enumerate}

\subsection[Hilfestellung]{Hilfestellung bei der Implementierung mittels abstrakten Klassen}
Es werden abstrakte Klassen angeboten, die
das Implementieren vereinfachen sollen. Siehe dazu Kapitel 8 \hyperref[abstrakt]{Abstrakte Hilfsklassen}.

\subsection{Bereitstellen der Klassen mittels ClassFileServer}
\label{classfileserver}
Wie schon erwähnt, müssen alle Problem-Klassen auf einem Webserver für alle
Computer des Systems erreichbar sein (also sowohl für Operatives, wie auch für den
Dispatcher). Dabei muss die benutzte Package-Hierarchie als Verzeichnisse nachgebildet werden.
Die Klassen können alternativ auch in einem Jar-File liegen, das ebenfalls die 
Package-Hierarchie nachbildet.\\
Falls kein Webserver zur Verfügung steht, kann der sog. {\tt
  Class\-File\-Server} benutzt werden. Dies ist ein von Sun geschriebener
Mini-Webserver, der nur dazu dient, Klassen an RMI-Applikationen
auszuliefern. Die Benutzung ist sehr einfach. Man starte den
ClassFileServer mit folgender Kommandozeile:\\
{\tt java de.unistuttgart.architeuthis.user.ClassFileServer <port> <root>}\\

Dabei ist:
\begin{description}
\item[port] Der Port auf dem der Webserver ansprechbar sein soll.
\item[root] Das Verzeichnis, das als Wurzel-Verzeichnis für die Dateien des
  Web\-servers dienen soll.
\end{description}
Danach sind unter {\tt http://<rechnername>:<port>/} alle Dateien und
Verzeichnisse unter {\tt<root>} erreichbar.

\subsubsection*{Achtung!}
Der ClassFileServer gibt beim Starten immer eine Usage-Meldung aus. Man
sollte sich dadurch  nicht irritieren lassen und glauben, man hätte falsche
Parameter übergeben. Außerdem werden alle Dokumente (nicht nur class-Dateien)
unterhalb des angegebenen Verzeichnisses zugänglich gemacht. Mas sollte
daher für die class-Dateien ein eigenes Verzeichnis erzeugen.


\section{Die Problem-Verarbeitung}
Zur Verarbeitung eines (serialisierbaren) Problems steht als Schnittstelle
zwischen Benutzer und Compute-System die Klasse
{\tt de.unistuttgart.architeuthis.user.ProblemComputation} zur Verfügung.
Diese bieten zwei Arten von Methoden:

\begin{description}
\item[computeProblem] Dieser Methode berechnet ein übergebenes serialisierbares
  Probem lokal, d.h.\ ohne Übertragung an das Compute-System. Diese Methode
  ist besonders in der Phase der Entwicklung nützlich, da z.B.\ Testausgaben
  möglich sind. Der Methode kann optional die vorzuschlagende Anzahl der 
  Teilprobleme und außerdem noch optional eine Instanz von
  {\tt RemoteStoreGenerator} übergeben werden.

\item[transmitProblem] Diese Methode überträge ein übergebenes serialisierbares
  Problem zur Verarbeitung an das Compute-System. Dabei ist zumindest der
  Rechnername des Compute-Managers anzugeben. Außerdem ist eine \emph{codebase},
  d.h.\ ein URL, unter dem die vom Problem benötigten Klassen abrufbar sind,
  oder ein Array von codebases entweder zu übergeben oder über das Property
  <code>java.rmi.server.codebase</code> beim Aufruf der JVM anzugeben. In
  jedem Fall kann zusätzlich (optional) noch Instanz von
  {\tt RemoteStoreGenerator} übergeben werden.
\end{description}

Die Verwendung der beiden Arten von Methoden ist ansonsten gleich und
unterscheidet sich nicht vom Aufruf von Methoden, die vom Benutzer selbst
implementiert wurden und lokal ablaufen.

Sollen mehrere Probleme nacheinander verarbeitet werden, sollte von der
oben genannten Klasse aus Effizienzgründen trotzdem nur eine Instanz erzeugt
werden.


\section{Der Problem-Übermittler}
Für den Ausnahmefall, daß ein Problem nicht serialisierbar ist, kann das
Problem vom Compute-Manager geladen und vollständig auf dem Compute-System
ausgeführt werden. Dazu steht die Klasse
{\tt de.unistuttgart.architeuthis.user.ProblemTransmitterImpl} zur Verfügung.
Sie bietet außerdem die Möglichkeit, während der Berechnung eines Problems
auf dem Compute-System nebenläufig eine Problem-Statistik oder auch eine
System-Statistik abzufragen oder die Berechnung des Problems abzubrechen.

Von der Klasse muß unter Angabe des Rechnernames des Compute-Managers
eine Instanz zu erzeugen. Die Klasse bietet mehrere Methoden mit dem Namen
{\tt transmitProblem}, mit denen ein nicht-serialisierbares und auch eine
Instanz eines serialisierbaren Problems zum Compute-System übertragen
werden kann. Bei einem nicht-serialisierbaren Problem, von dem eine Instanz
auf dem Compute-Manager erzeugt wird, ist ein Array mit serialisierbaren
Parametern für den Konstruktor anzugeben.

Als Beispiel für die Verwendung von {\tt ProblemTransmitterImpl}  kann die
Klasse\\
{\tt de.unistuttgart.architeuthis.testenvironment.myprime.PrimeNumbersParallel}
zusammen mit den anderen Klassen dieses Packages betrachtet werden.


\section{Ausführung eines eigenständigen Problems}
\subsection*{Kurzbeschreibung}
Für den Sonderfall, daß ein Problem komplett eigenständig ist und keine
Daten mit anderen Programmen austauscht und keine Eingaben vom Benutzer
benötigt, steht die Klasse
{\tt de.unistuttgart.architeuthis.user.ProblemTransmitterApp} zur Verfügung:

\subsection[Kommandozeilenapplikation]{Die Kommandozeilenapplikation}
Zuerst muss gesagt werden, dass bei Benutzung dieser
Kommandozeilenapplikation einige Einschränkungen in Kauf genommen
werden müssen. Es können beispielsweise keine Parameter an den
Konstruktor der eigenen Problem-Klasse übergeben werden, so dass alle
Initialisierungswerte bereits fest vorgegeben werden
müssen. Andererseits können damit ohne zusätzlichen Aufwand das Problem
an das Compute-System übermittelt und nebenbei auch die Statistiken
angeschaut werden.

\subsubsection[Kommandozeilenparameter]{Aufruf und
  Kommandozeilenparameter}
Die Kommandozeile zum Aufrufen der ProblemTransmitterApp:\\
{\tt java -Djava.security.policy=transmitter.pol\\
  de.unistuttgart.architeuthis.user.ProblemTransmitterApp\\
  -u <packageURL> -r <ProblemManager> -c <klassenname>\\
  -f <dateiname> -s -d -n -p}\\

\begin{description}
\item[-Djava.security.policy=transmitter.pol]
  Lädt die Po\-li\-cy-Da\-tei für den Pro\-blem-Über\-mit\-tler. Diese Datei 
  darf sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.user.ProblemTransmitterApp]
  Die Haupt-Klasse des Problem-Übermittlers.
\item[-u <packageURL>] Der URL des äußersten Pakets der Klassen des
  Problems. Die Adresse muss entweder mit ``/'' enden, falls die Klassen
  ungepackt in der Package-Hierarchie vorliegen, oder mit dem Namen der
  jar-Datei, die die Klassen in der Package-Hierarchie enthält. Anstatt
  einem vorhandenen Web-Server kann man auch
  den\hyperref[classfileserver]{ClassFileServer} verwenden.
\item[-r <ProblemManager>]
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}

\item[-c <klassenname>] Der vollständige Klassenname (inklusive aller Packages)
  der Klasse des Problems, die das Interface {\tt Problem} implementiert.\\
 {\bf Achtung:}
\begin{description} 
\item
Da bei der Übermittlung durch den Problem-Transmitter dem Problem keine
Parameter übergeben werden können, ist es notwendig, dass das Problem einen
parameterlosen Konstruktor implementiert, der mögliche Variablen mit den
benötigten Werten initialisiert.
\item
Die Unterverzeichnisse, die durch die Package-Struktur
  entstehen, müssen auf dem Webserver ebenfalls vorhanden
  sein. Beispiel: Die Klasse {\tt MyProblem} aus dem Package {\tt
  mypackage} ist unter der URL\\
  {\tt http://myserver/mydir/my\-pack\-age/My\-Prob\-lem\-.class} erreichbar.
  Dann muss der Parameter {\tt -w} den Wert {\tt http://my\-ser\-ver/my\-dir/}
  erhalten und der Parameter {\tt -c} den Wert {\tt my\-pack\-age.My\-Prob\-lem}.
\end{description}
\item[-f <dateiname>] Der Name der Datei, in dem die Lösung des Problems
  gespeichert werden soll. Die Lösung wird dabei einfach in ihrer
  serialisierten Form in die Datei geschrieben.
\item[-s] Optional. Überträgt das Problem als serialisierbares Problem.
\item[-d] Optional. Schaltet zusätliche Debug-Meldungen ein.
\item[-n] Optional. Schaltet die beiden graphischen Statistik--Fenster ab.
          Nach der Berechnung wird eine Statistik in Textform ausgegeben.
\item[-p] Optional. Startet nur das Fenster für die Problem--Statistik, nicht
          jedoch das für die System--Statistik.
\end{description}

Das Schließen der beiden graphischen Statistik--Fenster hat keinen Einfluß
auf die Berechnung des Problems. Die Berechnung des Problems kann jedoch
durch {\tt Strg-C} im Fenster, in dem das Problem gestartet wurde,
abgebrochen werden.


\section{Die Statistik}
\subsection*{Kurzbeschreibung}
Mit der Statistik können Informationen über den Zustand des 
Compute-Systems abgefragt werden. Diese werden graphisch aufbereitet 
ausgegeben.

\subsection{Voraussetzungen}
Die einzige Voraussetzung zum Anzeigen der Statistik ist ein
installiertes Java-Runtime-Environment der Version 1.3 oder neuer und eine
Netzwerkanbindung oder lokal auf dem Dispatcher-Rechner. Für die graphische Statistik-Ausgabe ist eine funktionierende graphische Oberfläche.

\subsection[Kommandozeilenparameter]{Aufruf und Kommandozeilenparameter}

Aufruf der graphischen Version:\\
{\tt java -Djava.security.policy=statisticreader.pol\\
de.unistuttgart.architeuthis.user.SystemGUIStatisticsReader <computeSystem>}

Aufruf der Konsole-Version:\\
{\tt java -Djava.security.policy=statisticreader.pol\\
de.unistuttgart.architeuthis.user.SystemTextStatisticsReader <computeSystem>}

\begin{description}
\item[-Djava.security.policy=statisticreader.pol]
  Lädt die Po\-li\-cy-Da\-tei für die Statistik-Anzeige. Diese Datei 
  darf sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe dazu das Kapitel
  \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.user.SystemGUIStatisticsReader]
  Die Haupt-Klasse der graphischen Statistik-Anzeige.
\item[de.unistuttgart.architeuthis.user.SystemTextStatisticsReader]
  Die Haupt-Klasse der textuellen Statistik-Anzeige.
\item{<computeSystem>}
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}


\end{description}

\section{Die Testumgebung}
\subsection*{Kurzbeschreibung}
Das Programm dient zum Vergleich zwischen der Berechnung eines Problems auf
einem einzelnen Computer und der Berechnung auf dem Compute-System. Es gibt jeweils
die L"osung bei beiden Berechnungen aus, sowie die gebrauchte Zeit und speichert
die L"osung von der verteilten Berechnung in einer anzugebenen Datei. 

\subsection{Lokale Berechnung}
Die Berechnung auf einem einzelnen Computer ist so realisiert, dass dem Problem mitgeteilt
wird, dass nur ein Operative zur Verf"ugung steht. Ob dann nur ein
Teilproblem generiert wird h"angt von der Implementierung des Problems ab.
Die generierten Teilprobleme werden jedenfalls nur von einem Operative
seriell berechnet und dann zur Gesamtl"osung zusammengefasst.

\subsection{Verteilte Berechnung}
Bei der verteilte Berechnung wird das Problem dem Compute-System mittels
dem Problem-Übermittler an ein Compute-System "ubergeben und berechnet.

\subsection[Kommandozeilenparameter]{Aufruf und
  Kommandozeilenparameter}
Die Kommandozeile zum Aufrufen der Testumgebung:\\
{\tt java -Djava.security.policy=transmitter.pol\\
  de.unistuttgart.architeuthis.user.ProblemTransmitterApp\\
  -u <packageURL> -r <ProblemManager>\\
  -c <klassenname> -f <dateiname> -d}\\
Dabei:
\begin{description}
\item[-Djava.security.policy=transmitter.pol]
  Die für die Testumgebung zu benutzende policy-Datei. Diese Datei darf
  sich nicht in einer Jar-Datei befinden; der Pfad muss also relativ
  oder absolut angegeben werden. Siehe Kapitel \hyperref[sicherh]{Sicherheit}.
\item[de.unistuttgart.architeuthis.testenvironment.Testumgebung]
  Die Haupt-Klasse der Testumgebung.
\item[-u <classURL>] Die vollständige Adresse inklusive Unterverzeichnisse
  des Webservers, auf dem die Klassen des Problems bereitgestellt
  werden. Man kann auch den\hyperref[classfileserver]{ClassFileServer} verwenden.
\item[-r <computesystem>] 
        Die Adresse der RMI-Registry, in der der
        Dispatcher eingetragen ist, an den sich der
        Operative anmelden soll. Exemplarisch:\\
         {\tt <Rechnername>:<Port>}\\
        Dabei:
        \begin{description}
        \item[Rechnername] Der Name oder die IP-Adresse des Rechners,
        auf dem der Dispatcher läuft.
        \item[Port] Optional. Der Port, auf dem der Dispatcher
        auf Verbindungen hört. Falls nicht angegeben, wird 1099 angenommen und
        außerdem muss der : dann entfallen.
        \end{description}
\item[-c <klassenname>] Der vollständige Klassenname (inklusive aller Packages)
  der Klasse des Problems, die das Interface Problem implementiert.\\
 {\bf Achtung:} Die Unterverzeichnisse, die durch die Package-Struktur
  entstehen, müssen auf dem Webserver ebenfalls vorhanden
  sein. Beispiel: Die Klasse {\tt MyProblem} aus dem Package {\tt
  mypackage} ist unter der URL {\tt
  http://myserver/mydir/my\-pack\-age/My\-Prob\-lem\-.class} erreichbar. Dann
  muss der Parameter -w den Wert {\tt http://my\-ser\-ver/my\-dir/} erhalten
  und der Parameter -c den Wert {\tt my\-pack\-age.My\-Prob\-lem}.
\item[-f <dateiname>] Optional. Der Name der Datei, in dem die Lösung des
  Problems gespeichert werden soll. Die Lösung wird dabei einfach in ihrer
  serialisierten Form in die Datei geschrieben. Wird kein Dateiname angegeben,
  wird die Lösung auf der Standard-Ausgabe ausgegeben.
\item[-d] Optional. Schaltet zusätliche Debug-Meldungen ein.
\end{description}

\chapter{Sicherheit}
\label{sicherh}
\section{Wichtiger Hinweis}
Bei Benutzung des Compute-Systems muss man sich dringend vor Augen führen, dass
man explizit anderen Benutzern erlaubt, Programme auf dem eigenen 
Dispatcher-Rechner und den Operative-Rechnern auszuführen. Mit der folgenden 
Massnahme ist es jedoch anderen Benutzern nicht möglich, schädlichen Code 
auszuführen. Dies gilt natürlich nur dann, falls die policy-Dateien und die 
Security-Manager korrekt eingebunden werden.

\section{Benutzung der policy-Dateien}
Durch die Angabe von {\tt -Djava.security.policy=<policy-Datei>} wird die 
Java Virtual Machine dazu veranlasst, den verwendeten Security-Manager 
entsprechend den Regeln in der policy-Datei zu konfigurieren. Die 
policy-Datei muss dazu frei zugänglich sein, darf sich also nicht in 
einer Jar-Datei mit den Klassen befinden. Deshalb ist der Pfad relativ oder absolut anzugeben.

\section{Die policy-Dateien}
Um eine möglichst große Sicherheit zu gewährleisten, werden in allen Teilen des
Systems Security-Manager verwendet (für nähere Informationen siehe bitte
Java-API-Dokumentation). Damit die einzelnen Programm-Teile dann nur die
nötigsten Rechte auf den ausführenden Computern erhalten, wurden die
policy-Dateien entwickelt. Außerdem bietet dieses Konzept den Vorteil, dass
jeder Benutzer in Klartext (zumindest beinahe) die Rechte einsehen kann, die
jedes einzelne Java-Programm hat, indem er direkt die policy-Dateien editiert.
Welche policy-Dateien im Einzelnen zu verwenden sind, findet sich bei den
Kapiteln zu den jeweiligen Programmteilen.
\par Wichtige Einschränkungen in den policy-Dateien sind:
\begin{itemize}
\item Kein Zugriff auf das Dateisystem (außer Problem-Übermittler).
\item Kein Zugriff auf die Systemeigenschaften.
\item Kein Zugriff auf die Security-Manager.
\end{itemize}
\par Erlaubt ist standard-mäßig jedoch:
\begin{itemize}
\item Jeglicher Netzwerkverkehr.
\end{itemize}
Für das Benutzen eines neuen RMIClassLoaderSpi für den Dispatcher und
eventuell für den Operative wird zusätzlich benötigt:
\begin{itemize}
\item Erstellen und Benutzen von eigenen ClassLoadern.
\item Zugriff auf die RMI-Codebase.
\item Zugriff auf Sockets, um den Socket zum Laden von Klassen zu setzen.
\end{itemize}
\par Die weiteren Einstellungen können direkt aus den policy-Dateien abgelesen
werden. Die oben genannten Einschränkungen können natürlich aufgehoben werden,
falls dies für ein Problem von Bedeutung ist. Möglich ist z.B. auch, nur
gewissen signierten Java-Klassen weitere Rechte zu geben. Dazu sei jedoch auf
die Dokumentation von Sun verwiesen.

\subsection{Höhere Sicherheit}
Die policy-Dateien können an einigen Stellen weiter eingeschränkt werden. So kann
auf dem Operative beispielsweise nur Netzwerk-Verkehr zu einem bestimmten
Dispatcher erlaubt werden. Um diese weiteren Einstellungen vorzunehmen wird 
jedoch empfohlen, die policy-Dateien direkt zu editieren, und die dortigen 
Kommentare zu lesen.

\subsection{Sicherheit für den Benutzer}
Da sich beliebige Operatives an das Compute-System zur Berechnung von
Teilproblemen anmelden dürfen, wäre es auch denkbar, dass die Ergebnisse dadurch
verfälscht werden, dass gehackte Operatives mutwillig falsche Ergebnisse
zurückliefern. Dies läßt sich beispielsweise dadurch verhindern, dass man in der
policy-Datei des Dispatchers nur gewissen Rechnern das Betreiben eines
Operatives erlaubt, indem man zu anderen Rechnern die Netzwerkverbindungen
untersagt. Beispiele dazu finden sich direkt in der Datei {\tt dispatcher.pol} oder
in der Java API Dokumentation unter {\tt java.net.Socket\-Permission}.


\chapter{Abstrakte Hilfsklassen}\label{abstrakt}
Alle abstrakten Hilfsklassen sollen nur eine Hilfestellung sein, (einfache)
Probleme schnell zu implementieren.

Die abstrakten Problem-Klassen bieten drei Funktionen an:

\begin{enumerate}
\item  Sie ordnen und liefern die Teillösungen in der Reihenfolge, in der
       die Teilprobleme erzeugt wurden. Diese Funktion ist bei allen drei
       abstrakten Klassen vorhanden.
\item  Sie fragen die Teilprobleme nicht einzeln sondern als Menge ab und
       liefern eine Menge der zughörigen Teillösungen. Diese Funktionalität
       ist nur bei \texttt{AbstractFixedSizeProblem} und\\
       \texttt{AbstractFixedSizePriorityProblem} vorhanden.
\item  Sie bearbeiten die Teilprobleme in einer durch Prioritäten
       vorgegebenen Reihenfolge. Diese Funktionalität ist nur bei\\
       \texttt{AbstractFixedSizePriorityProblem} vorhanden.
\end{enumerate}

Zusätzlich gibt es noch eine konkrete Teillösungs-Hilfsklasse.

Die Klassen sind nachfolgend einzeln beschrieben.


\section{AbstractOrderedProblem.java}
Diese Klasse sorgt dafür, das die Teillösungen in der gleichen Reihenfolge
geliefert werden, in der die zugehörigen Teilprobleme erzeugt wurden. Eine
onkrete Unterklasse muß dazu die beiden folgenden Methoden implementieren:

\begin{itemize}
\item createPartialProblem, die ein neues Teilprobem liefert. Als Parameter
  wird ihr die empfohlene Anzahl insgesamt zu erzeugender Teilprobleme
  übergeben.
\item receivePartialSolution, die jeweils eine Teillösung übergibt und als
  Rückabewert die Gesamtlösung erwartet, falls diese schon vorhanden ist,
  oder anderenfalls den Wert \texttt{null}.
\end{itemize}

Nachfolgend ist der komplette Quelltext angegeben.

{\scriptsize \verbatiminput{java/AbstractOrderedProblem.jav}}


\section{AbstractFixedSizeProblem.java}
Diese Klasse eignet sich für Probleme, die am Anfang schon alle Teilprobleme 
erstellen können, die auch alle für die Lösung erforderlich sind. Die Anzahl
kann  von der vom Dispatcher vorgeschlagenen Anzahl abhängen oder konstant
sein. Die Arbeit zum einzelnen Ausgeben der Teilprobleme, wie es der Dispatcher
fordert, und die Arbeit zum Sammeln der Teillösungen werden übernommen. D.h.
der Benutzer muss nur noch zwei Methoden implementieren:
\begin{itemize}
\item createPartialProblems, die bei der ersten Anfrage für ein Teilproblem
  aufgerufen wird und ein Array aller nötigen Teilprobleme erstellt. 
\item createSolution, die aufgerufen wird, wenn alle Lösungen eingegangen sind.
  Es muss auf jeden Fall eine Lösung erstellt werden können, ansonsten ist
  dieses Problem fehlerhaft und wird entfernt. Die Teillösungen im
  Übergabeparameter sind in der Reihenfolge der entsprechend Teilprobleme
  geordnet.
\end{itemize}

Nachfolgend ist der komplette Quelltext der Klasse angegeben.

{\scriptsize \verbatiminput{java/AbstractFixedSizeProblem.jav}}


\section{AbstractFixedSizePriorityProblem.java}
Diese Klasse benutzt die Klasse \texttt{AbstractFixedSizePriorityPartialProblem}.\\
Diese beiden Klassen eignen sich für Probleme, die am Anfang schon 
alle Teilprobleme erstellen können und diese in einer durch Priorisierung gekennzeichneten
Reihenfolge berechnet werden sollen. Die Kennzeichnung findet für jedes Teilproblem
individuell statt, indem dessen Priorität durch den Konstruktor gesetzt wird. Dabei bedeuten
höhere Werte eine höhere Priorität, d.h.\ dass dieses Teilproblem früher
berechnet wird.\\
Die Arbeit zum einzelnen Ausgeben der Teilprobleme in dieser Reihenfolge und 
das Sammeln der Teillösungen wird übernommen. Außerdem werden die Teillösungen
wieder in die Reihenfolge gebracht, wie ihre Teilprobleme erstellt wurden.
Der Benutzer muss folgende zwei Methoden implementieren, wobei die
Teilprobleme von \texttt{AbstractFixedSizePriorityPartialProblem} erben müssen.

\begin{itemize}
\item createPartialProblems, die bei der ersten Anfrage für ein Teilproblem aufgerufen wird und
  eine Liste aller nötigen Teilprobleme, deren Priorität gesetzt wurde, erstellt. 
\item createSolution, die aufgerufen wird, wenn alle Lösungen eingegangen sind. Es muss auf 
  jeden Fall eine Lösung erstellt werden können, ansonsten ist dieses Problem fehlerhaft und wird
  entfernt.
\end{itemize}

Bei der Implementierung des Teilproblems ist zu beachten, dass die Methode zur
Berechnung \texttt{compute} heißt (wie es durch das Interface
\texttt{PartialProblem} vorgegeben ist).

Nachfolgend ist der komplette Quelltext der beiden Klassen angegeben.

{\scriptsize \verbatiminput{java/AbstractFixedSizePriorityProblem.jav}}
{\scriptsize \verbatiminput{java/AbstractFixedSizePriorityPartialProblem.jav}}


\section{ContainerPartialSolution.java}
Diese Klasse kann dafür verwendet werden, ein serialisierbares Objekt, das
von einem Teilproblem erzeugt wurde, auf einfache Weise als Teillösung
zurückzugeben. Dazu wird das erzeugte Objekt vom Teilproblem dem Konstruktor
der Klasse {\tt ContainerPartialSolution} übergeben und kann vom Problem
dann mit der Methode {\tt getPartialSolution} abgefragt werden.

Nachfolgend ist der komplette Quelltext der Klasse angegeben.

{\scriptsize \verbatiminput{java/ContainerPartialSolution.jav}}

