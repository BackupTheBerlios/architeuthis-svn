%% Realease 1.0 dieser Software wurde am Institut für Intelligente Systeme der
%% Universität Stuttgart (http://www.informatik.uni-stuttgart.de/ifi/is/) unter
%% Leitung von Dietmar Lippold (dietmar.lippold@informatik.uni-stuttgart.de)
%% entwickelt.


\chapter[Beispiele zur Parallelisierung]{Der Weg zum parallelisierten Programm
         anhand eines Beispiels}

Dieses Kapitel beschreibt die einfache Parallelisierung eines vorgegebenen
Programms.


\section{Aufgabenstellung}

Man betrachte zunächst die Methode {\tt primzahlTeilbereich} aus
\texttt{de.unistuttgart.architeuthis.testenvironment.PrimeNumbers}:

{\scriptsize \verbatiminput{java/PrimzahlTeilbereich.jav}}

Ermittelt werden sollen also alle Primzahlen, die in einem Intervall von
zwei Zahlen liegen. Da dies so geschieht, daß die Zahlen einzeln überprüft
werden, ob sie jeweils eine Primzahl sind, sind die Überprüfungen
unabhängig voneinander. Die Gesamtaufgabe kann also recht einfach in
Teilaufgaben zerlegt werden, indem das Gesamtintervall in Teilintervalle
zerlegt wird. Jedes Teilintervall bildet dann ein Teilproblem und eine
Teillösung ist eine Liste der Primzahlen aus dem Teilintervall. Die
Gesamtlösung ergibt sich dann durch hintereinander hängen der Listen
der Teillösungen. Dabei ist zu beachten, daß die Primzahlen in der
Gesamtliste aufsteigend sortiert sein müssen.


\subsection{Implementierung}

Die Sortierung der Primzahlen in der Gesamtliste kann dadurch implizit
erfolgen, daß den Teilproblemen die Teilintervalle aufsteigend zugeordnet
werden (wie es naheliegend ist) und die Teillösungen (die Listen der
Primzahlen) in der entsprechenden Reihenfolge aneinander gehängt werden.
Da die Berechnung der Teilprobleme unabhängig voneinander ist, können sie
außerdem alle geleichzeitig erzeugt werden.

Die Rückgabe der Teillösungen in der Reihenfolge der Ausgabe der Teilprobleme
wird durch die zur Verfügung stehenden abstrakten Hilfsklassen
(s.\ Kapitel \ref{abstrakt}) erledigt. Da die Teilprobleme außerdem alle
gleichzeitig erzeugt werden können, kann die Klasse
\texttt{AbstractFixedSizeProblem} verwendet werden. Für diese müssen
die folgenden beiden Methoden implementiert werden:

\begin{itemize}
\item protected PartialProblem[] createPartialProblems(int suggestedParProbs)
\item protected Serializable createSolution(PartialSolution[] partialSolutions)
\end{itemize}

Deren Implementierung erfolgt wie schon beschrieben. In
\texttt{createPartialProblems} werden die Teilprobleme dadurch erzeugt,
daß jedem Teilproblem ein Teilintervall zugeordnet wird. In
\texttt{createSolution} werden dann alle Teillösungen ihrer Reihenfolge
im Array aneinandergehängt (zum konkreten Typ der Elemente von Array s.u.).
Das Gesamtintervall wird die Unter- und Obergrenze dem Konsruktor übergeben.
Nachfolgend die vollständige Implementierung der Problem-Klasse.

{\scriptsize \verbatiminput{java/basic/PrimeRangeProblemImpl.jav}}

Die Implementierung des Teilproblems erfolgt einfach dadurch, daß dem
Konstruktor wird das zu durchsuchende Teilintervall übergeben wird und
in der Methode \texttt{compute()} zur Berechnung der Primzahlen die
vorgegebene Methode \texttt{primzahlTeilbereich} aufgerufen wird. Um die
Liste als Teillösung zurückzugeben, wird die zur Verfügung stehende
Hilfsklasse \texttt{ContainerPartialSolution} verwandt. Aus dieser muß
die Liste dann in der schon oben genannten Methode \texttt{createSolution}
abgerufen werden. Nachfolgend die vollständige Implementierung der
Teilproblem-Klasse.

{\scriptsize \verbatiminput{java/basic/PrimePartialProblemImpl.jav}}


\section{Weitere Beispiele}

Weiter Beispiele kann man Package \texttt{de.unis.architeuthis.testumgebung}
finden. Hier eine kurze Auflistung der Probleme und jeweils eine kurze
Beschreibung dazu.

\begin{enumerate}
\item \texttt{de...testenvironment.prime.basic.PrimRangeProblemImpl}\\
	Dies ist das obige Beispiel dieses Kapitels mittels der abstrakten
        Klasse \texttt{AbstractFixedSizeProblem}.

\item \texttt{de...testenvironment.prime.PrimRangeProblemImpl}\\
        Dieses Problem macht das gleiche wie das obige Problem, nur daß
        die Aufteilung in Teilprobleme geschickter so erfolgt, daß der
        Rechenaufwand für die einzelnen Teilprobleme noch gleicher ist.

\item \texttt{de...testenvironment.prime.PrimSequenceProblemImpl}\\
	Dies ist das Beispiel f"ur Fortgeschrittene im n"achsten Kapitel.

\item \texttt{de...testenvironment.montecarlo.MonteCarloProblemImpl}\\
        Hier wird das MonteCarlo-Verfahren zur Bestimmung der Zahl $Pi$
        parallelisert. Man bekommt somit bei einer festgelegten Rechenzeit
        eine bessere Genauigkeit f"ur $Pi$.

\item \texttt{de...testenvironment.random.RandomProblemImpl}\\
        Hier wartet jedes Teilproblem einfach eine zuf"allige Anzahl von
        Sekunden. Dies ist f"ur Testzwecke recht interessant.

\item \texttt{de...testenvironment.fail.FailProblemImpl}\\
        Ein Problem für Testzwecke, bei dem die Abfrage nach einer Lösung
        immer den Wert \texttt{null} liefert.

\item \texttt{de...testenvironment.caching.CachingTestProblem}\\
        Hier werden drei Dummy-Klassen in den Teilproblemen geladen. Mit
        diesem Problem wurde verglichen, inwiefern sich das Laden von
        Klassen zeitlich bemerkbar macht. Siehe dazu auch im Kapitel
        Performance.

\item \texttt{de...testenvironment.hashstore.HashStoreProblemImpl}\\
        Bei diesem Problem benutzen die Teilprobleme das Package
        \texttt{de...remotestore.hashmap} als gemeinsamen Speicher.
\end{enumerate}

