%% Realease 1.0 dieser Software wurde am Institut für Intelligente Systeme der
%% Universität Stuttgart (http://www.informatik.uni-stuttgart.de/ifi/is/) unter
%% Leitung von Dietmar Lippold (dietmar.lippold@informatik.uni-stuttgart.de)
%% entwickelt.


\chapter[Beispiel f"ur Fortgeschrittene]{Beispiel f"ur Fortgeschrittene}

Dieses Kapitel beschreibt die Parallelisierung eines nicht--serialisierten
Problems, das vollständig auf dem Compute-System ausgeführt werden kann, das
also insbesondere keine Daten mit anderen Programmen austauschen muß und
keine Eingaben vom Benutzer benötigt. Das Kapitel dient daher primär der
Darstellung der Parallelisierung selbst, nicht der Darstellung der Benutzung
des Compute-Systems.

In einer realen Anwendung wird das Problem das Interface
{\tt SerializableProblem} implementieren und der Benutzer wird mit dem
Compute-Systems nur über die Klasse
{\tt de...user.ProblemComputation} interagieren.

\section{Die Problemstellung}
Aus dem vorigen Kapitel sind ja schon einige einfache Problem besprochen
worden. Nun soll ein Problem ohne abstrakte Hilfsklassen realisiert werden.\\
Man betrachte zunächst die beiden folgenden Methoden:

\begin{enumerate}
\item primzahlTeilfolge
        {\scriptsize \verbatiminput{java/PrimzahlTeilfolge.jav}}
\item primzahlTeilbereich
        {\scriptsize \verbatiminput{java/PrimzahlTeilbereich.jav}}
\end{enumerate}
\par
Ziel: Parallelisierung von der Methode primzahlTeilfolge


\subsection[Strategie]{Beschreibung der Strategie}
Am Anfang steht natürlich die Überlegung, ob die Methode {\tt prim\-zahl\-Teil\-folge} direkt
für eine verteilte Berechnung geeignet ist. Hier muss man jedoch feststellen, dass sich die 
Methode selbst nicht eignet, da hier ein großer Aufwand in die Kommunikation zwischen den
berechnenden Systemen gesteckt werden müßte.

\par
Jedoch fällt schnell auf, dass sich {\tt prim\-zahl\-Teil\-bereich} gut zum Verteilen
eignet, da hier jeder {\tt Operative} für sich alleine rechnen kann, ohne weitere Informationen
zu benötigen. Die Verwaltung (also das Aufstellen der tatsächlichen Teilfolge) kann von
der Klasse {\tt Problem} auf dem Dispatcher übernommen werden, da dies keinen großen Aufwand mehr bedeutet,
falls bereits alle nötigen Primzahlen vorliegen.


\par
Die grobe Strategie sieht also wie folgt aus:
\begin{itemize}
\item als {\tt Partial\-Problem} wird ein dynamischer {\tt Prim\-zahl\-Teil\-be\-reich} berechnet
\item das {\tt Problem} setzt diese Bereiche zusammen und rechnet die Anzahl der Primzahlen aus,
  um die gewünschte Teilfolge zu extrahieren
\end{itemize}

\section[Vorgehen]{Das Vorgehen zur Realisierung dieser Strategie}
Um diese Strategie durchzuführen müssen natürlich zuerst die spezifizierten Interfaces implementiert 
werden. Wir beginnen mit den einfach zu implementierenden:

\subsection{Implementierung von \texttt{PartialProblem}}
Klar ist, dass jedes Teilproblem den Bereich enthalten muss, in dem die Primzahlen bestimmt
werden sollen. Also legt man dazu Attribute an. Ebenso benötigt man eine Identifikationsnummer,
die später die Teillösung identifiziert, da hier die Reihenfolge wichtig ist, in der die 
Teillösungen verarbeitet werden. Dann modifiziere man den Konstruktor, so dass alle diese
Daten gleich gespeichert werden können.
\par
Zu guter Letzt wird noch {\tt compute()} implementiert, und zwar indem man einfach aus der Klasse
{\tt Primzahlen} die vorher ausgewählte Methode \\{\tt PrimzahlTeilberech} aufruft. Dabei muss
noch beachtet werden, dass die Identifikationsnummer auch der Teillösung übergeben wird.

{\scriptsize \verbatiminput{java/PrimePartialProblemImpl.jav}}

\subsection{Implementierung von \texttt{PartialSolution}}
Diese Klasse muss eigentlich nur das Ergebnis der Berechnung von {\tt Prim\-zahl\-Teil\-bereich}
kapseln und außerdem die Identifikationsnummer beinhalten.
Man erstellt also zwei {\tt get}-Methoden für die Identifikationsnummer und die {\tt Array\-List},
die als package-local definiert werden, und natürlich ebenfalls Attribute dafür.
Abschließend erstellt man noch einen Konstruktor, der eben diese beiden Werte als Parameter erwartet und diese
sofort in die Attribute speichert.

{\scriptsize \verbatiminput{java/PrimePartialSolutionImpl.jav}}


\subsection{Implementierung von \texttt{Problem}}
Nun wird es etwas komplizierter, da einige Überlegungen zuvor getätigt werden
müssen. Zunächst scheint es sinnvoll, eine obere Abschätzung für die größte
gesuchte Primzahl zu finden.
Wir benutzen hier eine Abschätzung nach Rosser und Schoenfeld (siehe:
J. B. Rosser and L. Schoenfeld. Approximate formulas for some functions of prime
numbers. Illinois Journal of Mathematics, 6:64--94, 1962), auf die hier nicht
weiter eingegangen wird. Die Abschätzung besagt, dass die n-te Primzahl mit
Sicherheit kleiner ist als n*(ln(n)+ln(ln(n))-1/2) für n > 15. Somit ist eine
einfache obere Grenze bekannt, bis zu der alle Zahlen untersucht werden müssen.
Nun muss man noch überlegen, auf welche Art man das gesamte zu untersuchende
Intervall auf die verschiedenen {\tt Operatives} aufteilt. Der Einfachheit
halber wählen wir hier eine äquidistante Aufteilung des Intervalls.

\par
Außerdem ist zu beachten, dass bei diesem Problem die Reihenfolge, in der die Lösungen eintreffen,
wichtig ist. So kann die Lösung Nr.5 nicht bearbeitet werden, bis Lösung Nr.4 eingetroffen ist. Um diesem
Problem zu begegnen, speichert man alle eintreffenden Lösungen zunächst in einer {\tt HashMap}, als Schlüssel
benutzt man die Identifikationsnummer. Anschließend kann man bequem in einer Schleife die aufeinanderfolgenden
Teillösungen verarbeiten. Dazu muss natürlich noch die Identifikationsnummer der Teillösung gespeichert werden,
die als nächste bearbeitet werden muss.
\par
Nun könnte man alle Lösungen in der {\tt HashMap} behalten und warten, bis genügend Primzahlen ermittelt wurden.
Das scheint jedoch nicht zweckmäßig. Effizienter ist es, bis zum Erreichen der gesuchten Untergrenze nur die
Anzahl der bisher gefundenen Primzahlen zu speichern. Erst falls diese Grenze überschritten wird, werden die
Primzahlen in die Gesamtlösung übernommen. Mit dieser Strategie können alle bearbeiteten Teillösungen sofort
aus der {\tt HashMap} entfernt werden.
\par
Falls nun der {\tt Dispatcher} nach der Gesamtlösung fragt, wird überprüft, ob die Gesamtlösung schon
die Länge des gesuchten Intervalls hat. Falls dies nicht der Fall ist, wird {\tt null} zurückgegeben, ansonsten
die Gesamtlösung.

{\scriptsize \verbatiminput{java/PrimeSequenceProblemImpl.jav}}

