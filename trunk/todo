            Weitere geplante Arbeiten und Ideen für Architeuthis


Stand: 28.04.2006


Änderungen größerer Wichtigkeit
-------------------------------

 * Benutzerhandbuch aktualisieren.

 * Prüfen, welche Meldungen nach dem lokalen Abbrechen der Ausführung der
   Klassen ProblemTransmitterImpl und OperativeImpl (also nach Auslösen des
   shutdownHook) ausgegeben werden sollen, da nach dem Abbrechen keine
   logging-Meldungen mehr ausgegeben werden.

 * Die lokale Berechnung von Teilproblemen durch die Methoden
   ProblemComputation.computeProblem parallelisieren, d.h. jedes
   Teilproblem in einem eigenen Thread ausführen.

 * Eine Möglichkeit vorsehen, daß ein asynchron laufender Thread zur
   Übertragung von Daten zum RelayStore eine Fehlermeldung an den Operative
   übergeben kann (z.B. als Rückgabewert beim Abmeldes des zentralen
   RemoteStore).

 * Seltene ClassCastException im Dispatcher (wahrscheinlich nur bei
   Verwendung von CacheFlushingRMIClSpi) beseitigen.

 * Alle Meldungen in eigene Dateien ausgliedern und eine englischsprachige
   Version anbieten (wurde schon partiell testweise realisiert).

 * Entkopplung der Kommunikation von Dispatcher und Operatives, z.B. durch
   Producer-Consumer-Queue. Dadurch könnte die Synchronisation im
   Dispatcher wesentlich vereinfacht werden. Evtl. sollte der Dispatcher
   (insb. der Computemanager) dann neu implementiert werden. Dabei wäre
   das in Java 1.5 neu enthaltene Package java.util.concurrent, das für
   Java 1.4 gesondert erhältlich ist, zu verwenden.


Änderungen geringerer Wichtigkeit
---------------------------------

 * Die Möglichkeit einbauen, daß dem Dispatcher zur Laufzeit über ein
   Administrationsinterface ein Befehl geschickt werden kann, z.B. daß
   er sich beenden soll (als Prototyp schon implementiert).

 * Steigerung der Skalierbarkeit durch eine mehrstufige (zweistufige)
   Hierarchie von Dispatchern.

 * Den Parameter dispatcherHost vom Konstruktor von ProblemTransmitterImpl
   in die Parameter dispatcherName und DispatcherPort aufteilen. Einen
   neuen Konstruktor ohne DispatcherPort (= default Port) erstellen.

   Gleiches gilt für die Parameter dispatcherHost der Methode transmitProblem
   von ProblemComputation.

 * In allen java-Dateien und in der Anleitung "ComputeSystems" und
   "ComputeServer" durch "Dispatcher" ersetzen.

 * Eine Möglichkeit einbauen, daß ein Operative einen Dispatcher im lokalen
   Netz selbst findet, ohne daß dessen Rechnername anzugeben ist (wurde
   schon testweise realisiert).

 * Das Logging einheitlich über die Klasse Logger realisieren, anstatt
   teilweise über die Methode Miscellaneous.printDebugMessage. log-level
   einheitlich definieren und implementieren.

 * Prüfen, warum eine jar-Datei in der angegebenen Codebase im Cache
   gehalten wird, d.h. die Klasse CacheFlushingRMIClSpi wirkungslos ist.

 * Prüfen, warum die jar-Dateien User.jar und Problems.jar so viele Klassen
   enthalten bzw. ob sie diese enthalten müssen.

 * Überlegen, ob das Package testenvironment aufgeteilt werden sollte in
   eines, das nur die Testprobleme enthält und eines, das diese benutzt.
   Die benutzenden Klassen liegen derzeit in den subpackages prime und
   myprime.


Weitere Ideen
-------------

 * Bei den beiden Methoden ProblemComputation.computeProblem zur lokalen
   Berechnung eines Problems den Typ SerializableProblem ändern in Problem,
   so daß auch nicht serialisierbare Probleme lokal berechnet werden können.

 * Der Dispatcher sollte auch hinter einer Firewall (auf festen Ports)
   laufen.

 * Kann man die Speichermenge, die ein spezieller Thread (für das
   jeweilige Problem) auf dem Dispatcher in Anspruch nehmen kann, begrenzen?

