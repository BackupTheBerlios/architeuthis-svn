%% Realease 1.0 dieser Software wurde am Institut für Intelligente Systeme der
%% Universität Stuttgart (http://www.informatik.uni-stuttgart.de/ifi/is/) unter
%% Leitung von Dietmar Lippold (dietmar.lippold@informatik.uni-stuttgart.de)
%% entwickelt.

\documentclass[10pt,ngerman]{article}
\usepackage{palatino}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\geometry{verbose,a4paper,lmargin=2cm,rmargin=2cm}
\pagestyle{headings}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage[dvips]{color}
\usepackage[dvips]{graphicx}
%\usepackage{longtable}
\usepackage{hyperref}
\usepackage[normalem]{ulem}
\usepackage{ngerman}

\newcommand\suppress[1]{}
\newcommand\deleted[1]{\xout{#1}}
\newcommand\revised[1]{\uline{#1}}
\newlength\wvtextpercent
\setlength\wvtextpercent{0.009\textwidth}

\newbox\strikebox
\def\strike#1{\setbox\strikebox \hbox{<#1>}\hbox{\raise0.5ex\hbox to 0pt{\vrule height 0.4pt width \wd\strikebox\hss}\copy\strikebox}}

\setlength\parindent{0pt}
\setlength{\parskip}{\smallskipamount}
\def\topfraction{1.0}
\def\bottomfraction{1.0}
\def\textfraction{0.0} 

\usepackage{babel}
\makeatother
\begin{document}

\title{Entwicklerhandbuch zum RMI-ComputeSystems Architeuthis}


\author{\begin{tabular}{cc}
Jürgen Heit&
juergen.heit@gmx.de\\
Andreas Heydlauff&
andiheydlauff@gmx.de\\
Ralf Kible&
ralf\_kible@gmx.de\\
Achim Linke&
achim81@gmx.net\\
\end{tabular}}


\date{Stand: 20.10.2003}

\maketitle
\tableofcontents{}

\listoffigures


\begin{abstract}
Dieses Dokument beschreibt die Realisierung des Dispatcher-Teils
des RMI-ComputeSystems Architeuthis anhand von UML Diagrammen, die 
Lösungsansätze dieser Realisierung im Hinblick auf bestimmte Grenzfälle 
der Teilproblemverteilung und die Funktionsweise der zugehörigen Module
und Komponenten. Dieses
Dokument ist eine erweiternde Ergänzung des Benutzerhandbuches von 
Architeuthis. Die hier verwendeten kursiv gedruckten
Begriffe sind dort im Glossar definiert.
\end{abstract}

\section{Zweck der Dispatcherkomponente des RMI-ComputeSystems}

Zweck der Dispatcherkomponente des RMI-ComputeSystems ist die verteilte
Berechnung von theoretisch beliebig vielen Aufgaben, auch \emph{Probleme}
genannt. Jeder Benutzer des Systems kann beliebig viele \emph{Probleme}
mittels je eines \textit{ProblemTransmitters}, der auch Bestandteil dieses
Softwarepakets ist, in das System übertragen. An das \emph{Problem}
werden bestimmte Forderungen gestellt. Die Erfüllung dieser Forderungen
stellt nur eine notwendige Bedingung dafür dar, dass das \emph{Problem}
terminiert und wird vom \textit{Problem-Manager} kontrolliert. Enthält
das \textit{Problem} des Benutzers Endlosschleifen, so werden mit
Sicherheit bestimmte Threads des Systems unbrauchbar, das heißt, dass
Teile des Systems, eventuell auch das ganze System, einfrieren können,
da sie für immer in einer Endlosschleife gefangen sein können. Solange
ein \textit{Problem} im \textit{ComputeSystem} zur Berechnung ist
und seine Lösung noch nicht feststeht, ist es Teil des Systems. (siehe auch Abschnitt \ref{text:sonderfaelle})

Ein \emph{Problem} ist ein Objekt, welches das Interface \emph{Problem}
implementiert. Für die Durchführung der verteilten Berechnung des
\emph{Problems} müssen \emph{Teilprobleme} vom \emph{Problem} erzeugt
werden können, die an die einzelnen \emph{Operatives} geschickt
werden. Das Schicken der \emph{Teilprobleme} an die \emph{Operatives}
sowie den Empfang ihrer Teillösungen übernimmt der \emph{Dispatcher}.
Bei der Ermittlung eines \emph{Teilproblems} übergibt der \emph{Dispatcher}
dem \emph{Problem} eine Integermaßzahl, die angibt, in wie
viele \emph{Teilprobleme} das \emph{Problem} sich günstigerweise teilen
sollte. Nach der Rückgabe von \emph{Teillösungen} durch die \emph{Operatives}
an den \emph{Dispatcher}, werden die \emph{Teillösungen} weiter
an das zugehörige \emph{Problem} geleitet, das aus ihnen die Gesamtlösung
zusammensetzen soll.


\section{Semantik der verwendeten UML-Diagramme}

Beim Entwurf der Dispatcherkomponente wurden wir vor das Problem gestellt,
dass auch UML 1.4 kaum Mittel anbietet, die Synchronisation gleicher Threads, die sich jedoch gegenseitig beeinflussen können, zu modellieren. 
Diese Art von Threads
werden in der vorliegenden Realisierung des Systems vor allem dann
aktiv, wenn mehrere \emph{Operatives} das gleiche \emph{Teilproblem}
berechnen und ein \emph{Operative} die \emph{Teillösung} dieses
\emph{Teilproblems} zurückliefert. Hierbei wird ein RMI-Thread zur
Teillösungsannahme erzeugt, der die Berechnungsthreads des \emph{Teilproblems}
für das gerade eine \emph{Teillösung} zurückgeliefert wurde, auf den
anderen \emph{Operatives} abbricht.

Dieser Vorgang, der später noch ausführlicher dargestellt wird, resultiert
aus der gleichzeitigen Berechnung eines \emph{Teilproblems} auf mehreren
\emph{Operatives} und macht die Synchronisationen bestimmter Datenobjekte
und Methoden auf \emph{Dispatcher-}Seite aber auch auf \emph{Operative}-Seite
notwendig. Um die benötigten Synchronisationen auch im Entwurf erkenntlich
zu machen, haben wir vielfach Zustandsboxen in Aktivitätsdiagrammen
verwendet um auf die Daten aufmerksam zu machen, die vor konkurrierenden
Zugriffen und Veränderungen für bestimmte durchzuführende Aktivitäten
vorrübergehend geschützt werden müssen. Wird eine Synchronisation
für bestimmte Daten für mehr als eine Aktivität benötigt,
so haben wir innerhalb dieser Zustandsboxen Anfangs- und Endzustände
verwendet, um kenntlich zu machen, mit welcher Aktivität begonnen 
beziehungsweise geendet wird, solange einem bestimmten Thread durch 
Synchronisation die Daten exklusiv zur Verfügung stehen.


\section{Art der Eingabe, die das ComputeSystems erwartet}

Der \textit{ProblemTransmitter} teilt dem \textit{Problem-Manager}
des \textit{ComputeSystems} den Ort und die Instanzierungsparameter
des \textit{Problems} mit. Der \textit{ProblemManger} instanziert
dann das \textit{Problem}. Die Berechnungszustände eines \emph{Teilproblems}
sind im Zustandsdiagramm aus Abbildung \ref{fig:ProblemStates} dargestellt.
\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=350pt]{Problem.eps}

      %\setcaptionwidth{\textwidth} 

      \caption{Berechnungszustände eines Problems test.testpackage.testclass}      

      \label{fig:ProblemStates} 

   \end{center} 

\end{figure} 


\section{Module des Systems und deren Komponenten}

Das Gesamtsystem ist, wie aus dem Benutzerhandbuch entnommen werden
kann, in folgende Teile gegliedert:

\begin{itemize}
\item \emph{Dispatcher}
\item \emph{Operative}
\item \emph{ProblemTransmitter}
\item \emph{StatisticReader}
\end{itemize}
In diesem Dokument wird nur der \emph{Dispatcher} betrachtet. Er
besteht aus folgenden Modulen:

\begin{itemize}
\item dem ProblemManaging, 
\item dem ComputeManaging 
\item und der Statistik. 
\end{itemize}
Diese Module sind wiederum unterteilt in einzelne Komponenten,
welche die einzelnen Funktionen des Systems realisieren.

Diese Funktionen sind:

\begin{itemize}
\item Die Möglichkeit \emph{Probleme} in das System zu laden. 
\item Die Versorgung der \emph{Operatives} mit Teilproblemen. 
\item Die Überwachung der Erreichbarkeit aller am System angemeldeten \emph{Operatives}. 
\item Die Bereitstellung von Informationen über den Betriebsstatus des \emph{ComputeSystems}
und statistischer Informationen über den Berechnungsvorgang eines \emph{Problems}. 
\end{itemize}

\subsection{Das ProblemManaging-Modul}

Das ProblemManaging-Modul besteht aus

\begin{enumerate}
\item dem Problem-Manager
\item und den InfoProblem-Objekten. 
\end{enumerate}
Dieses Modul wird im Klassendiagramm in Abbildung
\ref{fig:klassendiagramproblemmanaging} genauer dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=550pt]{klassendiagrammproblemmanaging.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Klassendiagramm des ProblemManaging-Moduls} 

      \label{fig:klassendiagramproblemmanaging} 

   \end{center} 

\end{figure} 


\subsubsection{Der Problem-Manager}

Der \emph{Problem-Manager} erhält vom \emph{ProblemTransmitter} eines
Benutzers den vollständigen Klassennamen (inklusive Packages) der
Problemhauptklasse, eine Liste der serialisierbaren Objekte für den
Aufruf eines bestimmten Konstuktors dieser Klasse und die URL, durch
die auf alle zum \emph{Problem} gehörenden Klassen sowohl von \emph{Operative}-
als auch von \emph{Dispatcher-}Seite zugegriffen werden kann. Der
\emph{Problem-Manager} verwaltet theoretisch beliebig viele \emph{Problem}-Objekte,
prüft deren Korrektheit im Sinne von Abbildung \ref{fig:ProblemStates}
und ordnet vom \emph{Compute-Manager} erhaltene \emph{Teillösungen}
den zugehörigen \emph{Problemen} zu, wie in Abbildung \ref{fig:collectResult}
dargestellt. Außerdem fordert der \textit{Compute-Manager} beim \textit{Problem-Manager}
\textit{Teilprobleme} an. Wie der \textit{Problem-Manager} mit den
\textit{\emph{Teilproblemsanfragen}} im Einzelnen umgeht entnehme
man bitte Abbildung \ref{fig:getPartialProblem}.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=550pt]{ProblemManagerImpl_getPartialProblem.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Ermittlung eines neuen Teilproblems vom Problem-Manager]
	      {\begin{tabular}{c}
		  Ermittlung eines neuen Teilproblems vom Problem-Manager\\ 
		  dispatcher.problemmanaging.ProblemManagerImpl.getPartialProblem(int)
	      \end{tabular} }         
      \label{fig:getPartialProblem} 

   \end{center} 

\end{figure} 


\subsubsection{Das InfoProblem-Objekt }

Jedes Problem hat ein \emph{InfoProblem}-Objekt. In diesem werden
die Referenzen auf \emph{Teilprobleme} gespeichert, die vom Compute-Manager
bereits angefordert wurden und für die noch keine \emph{Teillösung}
zurückgeliefert wurde. Muss ein \emph{Problem} entfernt werden, weil
seine Berechnung bereits vor der Rückgabe des letzten \emph{Teilproblems}
fertig ist oder weil das \emph{Problem} im Fehlerzustand im Sinne
der obigen Definition war, so weist der \emph{Problem-Manager} den
\emph{Compute-Manager} an, die Berechnung der übrigen \emph{Teilprobleme}
des \emph{Problems} abzubrechen. Darüber hinaus enthält das \emph{InfoProblem}-Objekt
eines \emph{Problem}-Objektes eine Referenz auf den \emph{ProblemTransmitter},
der das \emph{ComputeSystem} zur Berechnung des \emph{Problems} veranlasst
hat, damit festgestellt werden kann, an welchen \emph{ProblemTransmitter}
die Lösung des \emph{Problems} nach erfolgreicher Berechnung beziehungsweise
eine Fehlermeldung nach erfolgloser Berechnung geschickt werden muss. 


\subsection{Das ComputeManaging-Modul}

Das ComputeManaging-Modul besteht aus folgenden Komponenten:

\begin{enumerate}
\item dem Compute-Manager,
\item den InfoPartialProblem- und InfoOperative-Objekten,
\item der PartialProblemQueue,
\item und der OperativeMonitoringUnit.
\end{enumerate}
Die Beziehungen zwischen diesen Komponenten dieses Modul werden im folgenden Klassendiagramm
in Abbildung \ref{fig:klassendiagrammcomputemanaging} dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=550pt]{klassendiagrammcomputemanaging.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Klassendiagramm des ComputeManaging-Moduls} 

      \label{fig:klassendiagrammcomputemanaging} 

   \end{center} 

\end{figure} 


\subsubsection{Der \emph{Compute-Manager}}

Beim Starten des \textit{Compute-Managers} wird jeweils genau ein \textit{Problem-Manager},
genau ein \textit{PartialProblemQueue}-Modul, genau ein \textit{OperativeMonitoringUnit}
und genau ein \textit{Statistik}-Objekt, das Informationen über den
Betriebsstatus des Systems bereitstellt, instanziert. Der \textit{Compute-Manager}
sorgt dafür, dass \textit{Operatives}, die eine \textit{Teillösung}
zurückgeliefert haben, sofort wieder mit einem \textit{Teilproblem}
versorgt werden. Hierzu wird zunächst überprüft, ob es ein \emph{Teilproblem}
gibt, dessen Berechnung abgebrochen wurde, weil der einzige \textit{Operative},
der dieses \textit{Teilproblem} berechnet hat, nach erfolgreicher
Übergabe des \textit{Teilproblems} nicht mehr erreichbar war oder
weil bereits die Übergabe des \textit{Teilproblems} an einen freien
\textit{Operative} gescheitert ist. Die Übergabe eines Teilproblems
an einen Operative wird im Aktivitätsdiagramm in Abbildung \ref{fig:sendPartialProblemToClient}
genauer erläutert.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=\textwidth]{ComputeManagerImpl_sendPartialProblemToClient.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Übergabe eines Teilproblems vom Compute-Manager an einen Operative]{\begin{tabular}{c}
	  Übergabe eines Teilproblems vom Compute-Manager an einen Operative,\\
	  dispatcher.computemanaging.ComputeManagerImpl.sendPartialProblemToClient(\ldots)
	\end{tabular} }

      \label{fig:sendPartialProblemToClient} 

   \end{center} 

\end{figure} 


\subsubsection{\label{text:InfoOperative}Das InfoOperative-Objekt}

Um zuordnen zu können, für welches \emph{Teilproblem} ein \emph{Operative}
eine \emph{Teillösung} zurückgeliefert hat und um zu erkennen, welches
\emph{Teilproblem} einem \emph{Operative} übermittelt wurde, der nicht mehr erreichbar
ist, muss der \emph{Compute-Manager}
speichern, welches \emph{Teilproblem} von einem bestimmten \emph{Operative}
berechnet wird. Für jeden \emph{Operative}, der sich beim \emph{Compute-Manager}
anmeldet wird genau ein \emph{InfoOperative}-Objekt angelegt,
genau diese Informationen gespeichert werden. Ferner werden
im \emph{InfoOperative}-Objekt statistische Informationen über
die Berechnungsdauer des jeweiligen \emph{Teilproblems} gespeichert.


\subsubsection{Das InfoPartialProblem-Objekt}

Ein und dasselbe Teilproblem wird an mehrere \emph{Operatives}
vergeben, wenn die Anzahl der beim \emph{Compute-Manager} angemeldeten
\emph{Operatives} (vorrübergehend) größer als die Anzahl der von
allen \emph{Problemen} im \emph{Problem-Manager} generierten \emph{Teilprobleme}
ist. Um also bestimmte \emph{Operatives} nicht unnötig mit der
Berechnung eines \emph{Teilproblems} zu blockieren, wenn bereits
die \emph{Teillösung} feststeht, muss festgestellt werden, von welchen
\emph{Operatives} das \emph{Teilproblem} immer noch berechnet
wird, damit diese Berechnung abgebrochen werden kann. Für jedes \emph{Teilproblem},
das vom \emph{Problem-Manager} abgeholt wird, legt der \emph{Compute-Manager}
ein neues \emph{InfoPartialProblem}-Objekt an, in dem diese Informationen
gespeichert werden.


\subsubsection{Die PartialProblemQueue des \emph{Compute-Managers}}

Allen \textit{Teilproblemen}, die der \textit{Compute-Manager} vom \textit{Problem-Manager}
abgeholt hat und für die noch keine \textit{Teillösung} feststeht,
werden in der \textit{PartialProblemQueue} geführt. Die \textit{PartialProblemQueue}
ist in zwei Teile eingeteilt. In einem Teil sind die InfoPartialProblem-Objekte der\textit{Teilprobleme}
gespeichert, die vom \textit{Problem-Manager} abgeholt wurden, deren
Berechnung aber nicht abgeschlossen werden konnte, weil der \textit{Operative},
der dieses \textit{Teilproblem} berechnen sollte, ab irgendeinem
Zeitpunkt, von der Übergabe des \textit{Teilproblems} an, längere
Zeit nicht mehr erreichbar war. Im anderen Teil der \textit{PartialProblemQueue}
werden die InfoPartialProblem-Objekte der \textit{Teilprobleme} geführt, die sich derzeit in Berechnung
befinden und deren \textit{Operatives} noch erreichbar sind. \textit{Teilprobleme,}
deren Berechnung abgeschlossen ist, für die also eine \textit{Teillösung}
zurückgeliefert wurde, werden nicht mehr verwaltet und sind deshalb
auch nicht mehr in der \textit{PartialProblemQueue} enthalten. Auf
die \textit{PartialProblemQueue} greift nur der \textit{Compute-Manager}
zu.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=350pt]{ProblemManagerImpl_collectResult.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Rückgabe einer Teillösung an den Problem-Manager]
              {\begin{tabular}{c}
		  Rückgabe einer Teillösung an den Problem-Manager\\
		  dispatcher.problemmanaging.ProblemManagerImpl.collectResult(\ldots)
	       \end{tabular} }

      \label{fig:collectResult} 

   \end{center} 

\end{figure} 


\subsubsection{Die OperativeMonitoringUnit des Compute-Managers}

Beim Compute-Manager angemeldete \emph{Operatives} werden in regelmäßigen
Zeit-Intervallen auf ihre Erreichbarkeit überprüft. Dies ist deshalb nötig,
da der \emph{Operative}, nachdem ihm ein \emph{Teilproblem} übergeben
wurde, für den \emph{Compute-Manager} nicht mehr erreichbar sein könnte
und dieser \emph{Operative} seine \emph{Teillösung} eventuell
nie zurückliefern würde. Die Berechnung eines \emph{Problems} könnte
somit unendlich lange dauern. Die genaue Funktionsweise des OperativeMonitoringUnit
lässt sich aus Abbildung \ref{fig:OperativeMonitoringUnitThread_run}
entnehmen.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=600pt]{OperativeMonitoringUnit_run.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Funktionsweise der Operative-Erreichbarkeitsüberprüfung]
              {\begin{tabular}{c}
		  Funktionsweise der Operative-Erreichbarkeitsüberprüfung\\
		  dispatcher.computemanaging.OperativeMonitoringUnit.run()
	       \end{tabular} }

      \label{fig:OperativeMonitoringUnitThread_run} 

   \end{center} 

\end{figure} 


\subsection{Erhalt einer Teillösung eines Operatives}

Ein \emph{Operative}, der eine \emph{Teillösung} zurückgibt, erzeugt
einen RMI-Thread auf \emph{Dispatcher}-Seite. Bei der Rückgabe einer \emph{Teillösung} wird überprüft,
ob sich der \emph{Operative} überhaupt in der Verwaltung des \emph{Compute-Managers}
befindet. Falls nicht, so hat er sich nicht angemeldet oder er wurde
aus der Verwaltung entfernt, weil er längere Zeit für den \emph{Compute-Manager}
nicht erreichbar war und seine \emph{Teillösung} wird ignoriert. Falls
der \emph{Operative} sich zwar in der Verwaltung des \emph{Compute-Managers}
befindet, das \emph{Teilproblem}, für das er eine \emph{Teillösung}
zurückliefern will, aber nicht (mehr) existiert, so wird seine \emph{Teillösung}
auch ignoriert. In allen anderen Fällen wird die \emph{Teillösung}
an den \emph{Problem-Manager} weitergereicht, der ermittelt zu welchem
\emph{Problem} die \emph{Teillösung} gehört. Dieser Vorgang ist in
Abbildung \ref{fig:collectResult} dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=350pt]{ComputeManagerImpl_returnPartialSolution.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Rückgabe einer Teillösung an den Compute-Manager]
              {\begin{tabular}{c}
		  Rückgabe einer Teillösung an den Compute-Manager \\
		  dispatcher.computemanaging.ComputeManagerImpl.returnPartialSolution(\ldots)
	       \end{tabular} }
		

      \label{fig:returnPartialSolution} 

   \end{center} 

\end{figure} 


\subsubsection{Abbruch in Berechnung befindlicher Teilprobleme}

Ist ein und dasselbe \emph{Teilproblem} an mehrere \emph{Operatives}
zur Berechnung gegeben worden, so gibt es genau einen \emph{Operative},
dessen RMI-Thread auf \emph{ComputeSever}-Seite als erster die
Synchronisation auf die benötigten Datenstrukturen erhält um seine
Teillösung zurückzugeben. \emph{Teillösungen} zum selben \emph{Teilproblem},
die quasi zur selben Zeit von anderen \emph{Operatives} zurückgeliefert
werden, werden ignoriert. Bei allen \emph{Operatives}, mit Ausnahme
des ersten, dessen \emph{Teillösung} angenommen wurde, wird die Berechnung
des \emph{Teilproblems} abgebrochen. Durch geeignete Synchronisation
beim \emph{Operative} wird sichergestellt, dass der Abbruch der
Berechnung auf allen \emph{Operatives} vollständig erfolgt ist,
bevor alle \emph{Operatives}, die dasselbe \emph{Teilproblem}
berechnet haben, wieder mit neuen \emph{Teilproblemen} versorgt werden.
Dieser Abbruchvorgang ist in Abbildung \ref{fig:abortComputation},
\ref{fig:stopComputation} und \ref{fig:removeDeadClient} genauer
dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=350pt]{ComputeManagerImpl_abortComputation.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Abbruch der Berechnung eines Teilproblems auf mehreren Operatives]
      {\begin{tabular}{c}
	  Abbruch der Berechnung eines Teilproblems auf mehreren Operatives \\
	  dispatcher.computemanaging.ComputeManagerImpl.abortComputation(InfoPartialProblem)
       \end{tabular} }

      \label{fig:abortComputation} 

   \end{center} 

\end{figure} 

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=250pt]{ComputeManagerImpl_stopComputation.eps}         
      %\setcaptionwidth{\textwidth} 

      \caption[Abbruch der Berechnung eines Teilproblems auf einem bestimmten Operative]
      {\begin{tabular}{c}
	  Abbruch der Berechnung eines Teilproblems auf einem bestimmten Operative\\
	  dispatcher.computemanaging.ComputeManagerImpl.stopComputation(InfoOperative)
       \end{tabular} }

      \label{fig:stopComputation} 

   \end{center} 

\end{figure} 

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=350pt]{ComputeManagerImpl_removeDeadClient.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Entfernung eines nicht mehr erreichbaren Operatives]
              {\begin{tabular}{c}
		Entfernung eines nicht mehr erreichbaren Operatives \\
		dispatcher.ComputeManagerImpl.removeDeadClient(InfoOperative)
	       \end{tabular} }

      \label{fig:removeDeadClient} 

   \end{center} 

\end{figure} 


\subsubsection{Wiederversorgung eines freigewordenen Operatives}

Ein \emph{Operative} ist genau dann unbeschäftigt, wenn er sich
gerade beim \emph{Compute-Manager} angemeldet hat, eine \emph{Teillösung}
zurückgeliefert hat oder seine Berechnung abgebrochen wurde. Für jeden
unbeschäftigten \emph{Operative} wird ein \emph{Teilproblem} gemäß
Abbildung \ref{fig:distributePartialProblem} ermittelt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=350pt]{ComputeManagerImpl_distributePartialProblem.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption[Ermittlung eines Teilproblems für einen Operative]
              {\begin{tabular}{c}
		  Ermittlung eines Teilproblems für einen Operative \\
		  dispatcher.computemanaging.ComputeManagerImpl.distributePartialProblem(InfoOperative)
	       \end{tabular} }

      \label{fig:distributePartialProblem} 

   \end{center} 

\end{figure} 


\subsubsection{Threads des Compute-Managers}


\subparagraph{Der Hauptthread}

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=500pt]{ComputeManager_Global_Statechart.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Compute-Manager Haupt-Thread} 

      \label{fig:MainThread} 

   \end{center} 

\end{figure} 

In Abbildung \ref{fig:MainThread} ist der Haupt-Thread des \emph{Compute-Managers}
dargestellt. Das ist der Thread, der schon direkt nach dem Start des
Systems aktiv ist, ohne dass irgend etwas durch das System berechnet
werden muss.


\subparagraph{Der Operative-Erreichbarkeitsüberwachungs-Thread}

In Abbildung \ref{fig:OperativeMonitoringUnitThread} werden die
Zustände des Threads dargestellt, der angemeldete \emph{Operatives}
auf Erreichbarkeit überprüft. Sollte ein \emph{Operative} nicht
mehr erreichbar sein, wird er aus der Verwaltung entfernt. Sollte
dieser \emph{Operative} als einziger ein bestimmtes \emph{Teilproblem}
berechnet haben, für das noch keine \emph{Teillösung} zurückgeliefert
wurde, so wird dieses \emph{Teilproblem} sobald wie nur möglich einem
unbeschäftigten \emph{Operative} zugewiesen. Die Zuweisung von
\emph{Teilproblemen}, deren Berechnung abgebrochen wurde, weil der
\emph{Operative}, der es berechnet hat, nicht mehr erreichbar war,
hat Vorrang vor der Zuweisung eines neuen \emph{Teilproblems} an einen
\emph{Operative}. Dieser Thread ist ab der Anmeldung des ersten
\emph{Operatives} aktiv und wird erst beendet, wenn das gesamte
System beendet wird. Seine Funktionweise wird detaillierter in UML-Diagramm
aus Abbildung \ref{fig:OperativeMonitoringUnitThread_run} dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=350pt]{OperativeMonitoringUnit_Statechart.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Operative-Erreichbarkeitsüberwachungsthread} 

      \label{fig:OperativeMonitoringUnitThread} 

   \end{center} 

\end{figure} 


\subparagraph{Die RMI-Operatives-Threads}

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=500pt]{ComputeManager_RMI_Operative_Thread_Statechart.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Operative RMI-Thread} 

      \label{fig:OperativeRMIThread} 

   \end{center} 

\end{figure} 

Abbildung \ref{fig:OperativeRMIThread} soll einen Überblick über
die Zustände des Threads liefern, der für die Kommunikation von \emph{Operative}
und dem \emph{Dispatcher} mittels RMI nötig ist, um dem \emph{Operative}
ein \emph{Teilproblem} zuzuschicken, beziehungsweise eine \emph{Teillösung}
von einem \emph{Operative} zu empfangen. Aus der technischen Sicht
von RMI bilden diese beiden Vorgänge zwar in jeweils eingenen Threads
ab, da sie jedoch zusammengehören, seien sie der Übersichtlichkeit
und Verständlichkeit wegen in einem Zustandsdiagramm zusammengefasst.
Schließlich würde die Rückgabe einer \emph{Teillösung} keinen Sinn
machen, wenn kein \emph{Teilproblem} ausgegeben worden wäre.


\subsubsection{Betrachtung zweier wichtiger Grenzfälle\label{text:sonderfaelle}}

Im Folgenden sollen zwei wichtige Problemfälle und ihr realisierter
Lösungsansatz bei der Objektsynchronisation zwischen einem \emph{Operative}
und dem \emph{Dispatcher} beschrieben werden. Auf diese Fälle soll
hier deshalb gesondert hingewiesen werden, da diese wahrscheinlich
nicht sofort aus der Betrachtung der beigefügten Diagramme ersichtlich sind und auch uns anfänglich etwas Kopfzerbrechen bereitet haben.


\subparagraph{Berechnung, Teillösungsrückgabe und Abbruch eines Teilproblems auf
\emph{Operative}-Seite}

Wird ein \emph{Teilproblem} von mehreren \emph{Operatives} gleichzeitig
berechnet, kann es durchaus vorkommen, dass die Berechnung auf verschiedenen
\emph{Operatives} gleichzeitig oder fast gleichzeitig beendet
ist und die ermittelte \emph{Teillösung} an den \emph{Compute-Manager}
zurückliefert werden soll. In diesem Fall erhält ein \emph{Operative}
die Synchronisation auf die nötigen Objekte auf \emph{Dispatcher}-Seite,
um die \emph{Teillösungen} zurückzuliefern. Die \emph{Teillösung}
der anderen bereits fertigen \emph{Operatives} wird verworfen.
Die \emph{Operatives}, die noch mit der Berechnung dieses \emph{Teilproblems},
für das gerade die \emph{Teillösung} zurückgeliefert wurde, beschäftigt
sind, müssen angewiesen werden ihre Berechnung abzubrechen. Anschließend
wird versucht, die \emph{Operatives} mit anderen \emph{Teilproblemen}
wieder zu versorgen. Nun kann es aber sein, dass ein \emph{Operative}, mit der Berechnung seines \emph{Teilproblems} fertig ist und anschließend seine \emph{Teillösung} zurückliefert, obwohl man eigentlich gerade die Berechnung dieses \emph{Teilproblems} abbrechen wollte. Da der \emph{Operative} dabei
ist eine \emph{Teillösung} zurückzuliefern, hätte er kein \emph{Teilproblem}
in Berechnung und würde für den \emph{Compute-Manager} unbeschäftigt
erscheinen. In Wahrheit ist der \emph{Operative} aber noch damit beschäftigt seine Teillösung (die verworfen wird, s.o.) zurückzuliefern. Es muss jetzt sichergestellt werden, dass dem Operative nun solange kein neues Teilproblem zugewiesen wird, bis dieser Vorgang beendet wurde. 

Die Lösung dieses Problems ist jedoch sehr einfach. Sie besteht lediglich
darin, die \emph{Operative} Methoden zur Annahme eines neuen \emph{Teilproblems}
und zur Teillösungsrückgabe zu synchronisieren. So ist die Annahme
eines neuen \emph{Teilproblems} so lange blockiert, bis die Rückgabe
seiner \emph{Teillösung} mit Sicherheit beendet ist, für den Fall,
dass sie überhaupt schon eingesetzt hatte.


\subparagraph{Beendigung der Berechnung eines Problems und Laden eines neuen Problems}

Steht nur ein \emph{Problem} zur Berechnung im \emph{Problem-Manager}
an, so wird seine Berechnung irgendwann beendet, falls natürlich die
Problemmethoden zur Abholung eines \emph{Teilproblems} und zur Annahme
einer \emph{Teillösung} keine Endlosschleifen enthalten. Kurz bevor
die Berechnung des \emph{Problems} vollständig beendet ist, befindet
sich nur noch ein \emph{Teilproblem} in Berechnung. Wenn auch seine
Berechnung beendet ist, müssen in der Regel noch laufende Berechnungen
auf anderen \emph{Operatives} gestoppt werden. Für die \emph{Operatives},
deren Berechnung jetzt gestoppt wird, ist kein \emph{Teilproblem}
mehr im System verfügbar, da kein \emph{Problem} mehr im \emph{Problem-Manager}
vorhanden ist. Das Stoppen der Berechnungen funktioniert aber nicht
gleichzeitig, sondern wird nacheinander für jeden \emph{Operative}
ausgeführt. Wenn dieser Stoppvorgang also nicht vollständig für alle
\emph{Operatives} beendet ist, bevor das nächste Problem in den
\emph{Problem-Manager} geladen wird, so sind einige \emph{Operatives}
inaktiv, weil für sie kein \emph{Teilproblem} zur Verfügung stand,
andere hingegen sind noch aktiv, weil ihre Berechnung noch läuft und
für sie durch das neu geladene \emph{Problem} auch wieder \emph{Teilprobleme}
zur Verfügung stehen. Vorausgesetzt, dass neu geladene Problem liefert
überhaupt \emph{Teilprobleme}. Wichtig ist also die genaue Unterscheidung
des Zustandes, in denen ein \emph{Operative} kein \emph{Teilproblem}
hat, weil er gerade eine \emph{Teillösung} zurückgeliefert hat, vom Zustand in dem der \emph{Operative} kein Teilproblem hat,
weil kein \emph{Teilproblem} mehr im System verfügbar war. Das bedeutet auch: Der \emph{Operative} muss \emph{genau in einem dieser Zustände} sein und nicht etwa in einem undefinierten, in dem sich gerade sein Aktivitätsstatus ändert. Nur \emph{Operatives} dürfen reaktiviert werden, die inaktiv waren. Für \emph{Operatives}, die \emph{nicht inaktiv} sind muss sicher feststehen, dass sie aktiv sind und nicht im Begriff ihren Betriebszustand zu ändern. Um sich
den Unterschied dieser Zustände klar zu machen betrachte man die Zustandsdiagramme
aus Abbildung \ref{fig:MainThread} und \ref{fig:OperativeRMIThread}.


\subsection{Die Statistik}

Der \emph{Dispatcher} bietet dem Benutzer zwei verschiedene Statistiken an (siehe auch Abbildung \ref{figure:klassendiagrammstatistik}: 

\begin{itemize}
\item eine allgemeine Statistik 
\item und problemspezifische Statistiken.
\end{itemize}
Beide Statistiken können über den \emph{Problem-Manager} abgefragt
werden und stellen nur eine Momentaufnahme zeitlich abhängiger statistischer
Daten dar.

\begin{figure}[h]

   \begin{center} 

      \includegraphics*[trim=15 150 18 150]{klassendiagrammstatistik.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Klassendiagramm des Statistik-Moduls des ComputeSystems} 

      \label{fig:klassendiagrammstatistik} 

   \end{center} 

\end{figure} 


\subsubsection{Allgemeine Statistik }

Die allgemeine Statistik stellt Informationen über das \emph{ComputeSystem}
bereit. Sie kann ohne Einschränkungen von jeder interessierten Person
unter Verwendung des \emph{StatisticReaders} abgefragt werden. Folgende
Informationen sind enthalten: 

\begin{itemize}
\item Anzahl der angemeldeten \emph{Operatives}
\item Anzahl der \emph{Operatives}, die gerade kein \emph{Teilproblem}
berechnen
\item Anzahl der noch nicht gelösten \emph{Probleme}
\item Anzahl der insgesamt erhaltenen \emph{Probleme}
\item Anzahl der gelösten \emph{Teilprobleme}
\item Anzahl der gerade in Berechnung befindlichen \emph{Teilprobleme}
\item durchschnittliche Berechnungsdauer der \emph{Teilprobleme}
\item Summe der Berechnungszeit aller berechneten \emph{Teilprobleme}
\item Vergangene Zeit, seit dem Start des \emph{Dispatchers}
\end{itemize}

\subsubsection{Problemspezifische Statistik }

Eine problemspezifische Statistik stellt Informationen über den Fortschritt
eines einzelnen \emph{Problems} bereit. Für jedes Problem, dass sich
im Problem-Manager befindet, gibt es eine problemspezifische Statistik.
Sie kann nur vom Sender des \emph{Problems} abgefragt werden. Folgende
Informationen sind enthalten: 

\begin{itemize}
\item Anzahl der fertig berechneten \emph{Teilprobleme} seines \emph{Problems} 
\item Anzahl der gerade in Berechnung befindlichen \emph{Teilprobleme} 
\item durchschnittliche Berechnungsdauer seiner \emph{Teilprobleme} 
\item Summe der Zeit aller berechneten \emph{Teilprobleme} 
\item Anzahl der aktuell vorgeschlagenen \emph{Teilprobleme} vom \emph{Compute-Manager} 
\item Vergangene Zeit, seit Anweisung des \emph{Problem-Managers} das \emph{Problem}
zu berechnen.
\end{itemize}

\section{Verbesserungs- und Erweiterungsmöglichkeiten des Systems}


\subsection*{Teillösungsrückgabe}

Als kleinen Unfall beim Design des ComputeSystems kann man bezeichnen,
dass ein \emph{Problem} nicht automatisch eine Referenz auf das zugehörige
\emph{Teilproblem} bekommt, wenn ihm eine \emph{Teillösung} vom \emph{Problem-Manager}
übermittelt wird. Diese Verwaltungsaufgabe kann zwar direkt vom \emph{Problem}
übernommen werden, ist aber natürlich mit einem Mehraufwand für den
Benutzer des \emph{ComputeSystems} verbunden, der selbsterstellte
\emph{Probleme} berechnen lassen will. Eine simple Erweiterung der
Parameterliste der Problemmethode zur Teillösungsannahme löst jedoch
dieses \emph{Problem}. Wir konnten diese kleine Änderung aus Zeitgründen
leider nicht mehr so durchführen, dass die korrekte Funktionsweise
sichergestellt gewesen wäre.


\subsection*{Benennung der Teile des Gesamtsystems }

Obwohl, dank der Existenz des Glossars im Benutzerhandbuch, keine
Missverständnisse auftreten sollten, welcher Teil des Systems eine bestimmte
Aufgabe übernimmt, sind wir uns durchaus bewusst, dass man geteilter Meinung 
sein kann, ob die Bezeichnung der einzelnen Teile
des Gesamtsystems \emph{Dispatcher}, \emph{Operative} und \emph{ProblemTransmitter}
dem üblichen Sprachgebrauch entsprechen. \emph{}Einerseits bietet
der \emph{Dispatcher} aus der Sicht des Benutzers den Dienst der verteilten
Berechnung eines \emph{Problems} an, andererseits ist der Dispatcher
aus Sicht des Entwicklers eine Einheit, welche die Erledigung von
Aufgaben (hier \emph{Problemen} und \emph{Teilproblem}) steuert und
überwacht und den Dienst des \emph{Operatives} benutzt um \emph{Teilprobleme}
zu berechnen. Also ist der Dispatcher aus Sicht des Entwicklers
ein ,,Client'' und der Operative ein ,,Server''?! Eigentlich
ja, aber diese genaue Unterscheidung ist vermutlich für einen Benutzer
des Systems verwirrend. Er sieht sich mit seinem \emph{ProblemTransmitter}
eher als ,,Client'' und den \emph{Dispatcher} als einen Berechnungsdienst
anbietenden ,,Server''. Aus diesem Grunde wurde auch in diesem Handbuch
versucht den Zweck der einzelnen Komponenten nochmals anschaulich
darzulegen. Für Vorschläge zur Benennung der einzelnen Teile
des Systems sind die Autoren jedoch dankbar.


\subsection*{Erfassung der Berechnungsdauer für \emph{Teilprobleme}}

Bei der derzeitigen Erfassung der Berechnungsdauer eines \emph{Teilproblems}
durch den \emph{Compute-Manager} mit Hilfe der \emph{InfoOperative}-Objekte
wird nicht berücksichtigt, dass zwischen Inizierung der Übergabe einer
\emph{Teillösung} an den \emph{Problem-Manager} und der tatsächlichen
Durchführung dieses Vorgangs relativ viel Zeit vergehen kann, wenn
sehr viele RMI-Operative-Threads aktiv sind. Eine Zeiterfassung
der Berechnungsdauer für \emph{Teilprobleme} auf dem \emph{Problem-Manager}
(von deren Ausgabe bis zum Eingang der Teillösung) würde daher in der Regel 
längere Zeiten liefern.


\subsection*{Verzicht auf InfoOperative- und InfoPartialProblem-Objekte}

Würde man auf die Erfassung der Berechnungsdauer eines \emph{Teilproblems}
mit Hilfe der InfoOperative-Objekte (siehe Abschnitt \ref{text:InfoOperative})
verzichten, ließe sich die Zuordnung von \emph{Operatives} zu
\emph{Teilproblem} eventuell mit Datenstrukturen realisieren, die
einen effizienteren Zugriff auf ein bestimmtes Datum ermöglichen als
linearen Listen. Beispielsweise wäre es denkbar, die Zuordnung von
\emph{Teilproblem} zu \emph{Operative} mit einer Java-HashMap
zu realisieren. Andererseits scheint es keinen Sinn zu machen, bei
der Zuordnung von \emph{Operatives} zu \emph{Teilproblem} auf
lineare Listen zu verzichten, da zum Beispiel der Vorgang des Abbruchs
der Berechnung eines \emph{Teilproblems} rein sequenziell verläuft.
Es bleibt zu untersuchen, ob es eine Möglichkeit gibt, diese Zuordnungen
effizienter zu realisieren.


\subsection*{Vermeidung von unnötigen Datenübertragungen im Netzwerk}

Bei der derzeitigen Realisierung des \emph{ComputeSystems} liefern
alle \emph{Operatives} ihre \emph{Teillösung} zurück, sofern die
Berechnung des \emph{Teilproblems} nicht vorher schon abgebrochen
wurde. Hat der \emph{Compute-Manager} aber bereits schon davor von
einem anderen \emph{Operative} die \emph{Teillösung} für dieses
\emph{Teilproblem} erhalten, so ist jede weitere Übertragung der \emph{Teillösung}
überflüssig, da \emph{Teillösungen} zum selben \emph{Teilproblem}
nicht miteinander verglichen werden. Eine mögliche Verbesserung wäre
deshalb, den \emph{Operative} dem \emph{Compute-Manager} erst mitteilen
zu lassen, dass der fertig ist. Der \emph{Compute-Manager} könnte daraufhin 
entscheiden, ob er die \emph{Teillösung} abholen möchte, oder
ob er den \emph{Operative} anweist, die \emph{Teillösung} selbst
zu verwerfen. 


\subsection*{Komfortabler die Gesamtlösung eines \emph{Problems} erhalten}

Im Moment muss der \emph{ProblemTransmitter} während der gesamten
Berechnung des \emph{Problems} mit dem \emph{Problem-Manager} verbunden
bleiben. Interessant wäre eine Erweiterung des Systems, die es dem
Benutzer gestattet, die Verbindung zwischen \emph{Problem-Manager} und
\emph{ProblemTransmitter} zu trennen und später die vom \emph{Problem-Manager}
zwischengespeicherte Lösung abzurufen. Eine ähnliche Erweiterungsmöglichkeit
wäre, die Lösung eines \emph{Problems} als Email-Attachment an den
Übermittler des \emph{Problems} zu schicken. Bei beiden Erweiterungen
muss jedoch auch eine eindeutige Identifizierung des Benutzers und
Zuordnung zum \emph{Problem} sichergestellt werden. Der Zugriff auf
Lösungen zu \emph{Problemen}, die man nicht selbst übermittelt hat,
sollte vermutlich in den meisten Fällen vermieden werden oder einschränkbar
sein.


\subsection*{Der Java-RMIClassLoader des \emph{Dispatchers}}

Bei den derzeit aktuellen Versionen von Java 1.3 und 1.4 cachen prinzipiell
alle ClassLoader. Dies kann zu Problemen führen, wenn ein Benutzer
das \emph{ComputeSystem} auffordert, ein \emph{Problem} an einer bestimmten
URL zu berechnen, dieses \emph{Problem} modifiziert, die alten Klassen
mit den modifizierten überschreibt und das System erneut zur Berechnung
des \emph{Problems} auffordert. Da das System aber die alten Klassen
noch zwischengespeichert hat, sofern es zwischenzeitlich nicht neu
gestartet wurde, sind die Änderungen des Benutzers ab der zweiten
Berechnung des \emph{Problems} wirkungslos. Um vom Caching so viel
wie möglich zu profitieren und gleichzeitig den oben beschriebenen
Effekt zu umgehen, haben wir das Standardmodul \emph{RMIClassLoaderSpi} des
Java \emph{RMIClassLoaders} durch unseren \emph{NonCachingRMIClSpi} ersetzen
müssen. Bei der \emph{NonCachingRMIClSpi} handelt es sich nicht um
einen \emph{RMIClassLoader}, sondern um eine Unterklasse des \emph{RMIClassLoaderSpi}.
Diese Klasse ist ein sogenannter Service Provider für den \emph{RMIClassLoader,}
der alle Dienste bereitstellt, die der \emph{RMIClassLoader} nach
außen hin anbietet - also speziell das Klassenladen. Dazu verwaltet
das Objekt \emph{NonCachingRMIClSpi} intern eine Liste, in der URLs
und die dazugehörigen \emph{ClassLoader} gespeichert werden, wobei
es sich um \emph{URLClassLoader} handelt. Beim Klassenladen von einer
bestimmten URL wird immer der gleiche \emph{ClassLoader} verwendet.
Dieser Aufwand wird dadurch erforderlich, dass in Java die Identität
eines Objektes nicht allein durch die Instanzierung einer bestimmten
Klasse festgelegt ist, sondern auch durch den \emph{ClassLoader},
der bei der Instanzierung verwendet wurde. Ein \emph{ClassLoader}
wird aus der Verwaltungsliste gelöscht, wenn ein \emph{Problem}, dessen
Klassen von einer bestimmten URL abgerufen wurden, entfernt wird.
Dadurch wird ein Caching von Klassen, die von der gleichen URL abgerufen
werden, vermieden. Muss auf bestimmte Klassen von einer URL während
der Berechnung eines bestimmten \emph{Problems} aber mehrfach zugegriffen
werden, so funktioniert das Caching auch weiterhin. Leider führt dieses
Vorgehen aber zu anderen Schwierigkeit: Sollte ein Benutzer mehrere
\emph{Probleme} an einer URL bereitstellen und diese so dem \emph{ComputeSystem}
zur Berechnung übergeben, dass sich mindestens zwei dieser \emph{Probleme}
zur gleichen Zeit in Berechnung befänden, so würde der \emph{ClassLoader}
zu dieser URL entfernt werden, sobald das erste \emph{Problem} aus
dem \emph{Problem-Manager} entfernt wird. Für die anderen \emph{Probleme}
an dieser URL existiert dann aber kein \emph{ClassLoader} mehr, was
zum Wurf einer ,,Exception'' führen und den Abschluss der Berechnung
aller weiteren \emph{Probleme} von der gleichen URL verhindern würde.
Ein Benutzer des \emph{ComputeSystems} darf folglich nur ein Problem
von einer bestimmten URL dem System zur gleichzeitigen Berechnung
übergeben. Eine Behebung dieser Einschränkung hierfür steht noch aus. 


\subsection*{Der RMI-ClassLoader auf \emph{Operative}-Seite}

Muss ein \emph{Operative} mehrere \emph{Teilprobleme} des gleichen
\emph{Problems} berechnen ist es eventuell günstig, wenn auch der
\emph{Operative} bereits geladene Klassen cachet. Allerdings bekommt
ein \emph{Operative} es bislang nicht mit, wenn ein \emph{Problem}
aus dem \emph{Problem-Manager} entfernt wird und von ihm folglich keine
\emph{Teilprobleme} mehr zu erwarten sind. Also kann nicht entschieden
werden, wann der Cache eines \emph{Operatives} sinnvollerweise
geleert und der ClassLoader zu einer URL gelöscht werden kann. Eine denkbare Möglichkeit hierfür wäre, allen
\emph{Operatives} eine Broadcast-Nachricht zu schicken, wenn ein
\emph{Problem} aus dem \emph{Problem-Manager} entfernt wird. Fraglich
ist jedoch, ob dieser Mehraufwand für die Verwaltung des Cachings
auf Seite des \emph{Operatives} und die Broadcast-Aufrufe durch
den \emph{Compute-Manager} nicht mehr Zeit und Systemressourcen verbrauchen,
als überhaupt durch Caching auf Seite der \emph{Operatives} gewinnbar
ist.


\subsection*{Synchronisation auf die Liste der inaktiven \emph{Operatives}}

Um dem Sonderfall ,,Beendigung der Berechnung eines \emph{Problems}
und laden eines neuen \emph{Problems}'' (siehe auch Abbildung \ref{text:sonderfaelle}) Rechnung zu tragen und inaktive
\emph{Operatives} von aktiven \emph{Operatives}, die sich
im Zyklus der Teilproblemannahme und Teillösungsrückgabe befinden
(siehe Abbildung \ref{fig:OperativeRMIThread}), zu unterscheiden,
werden \emph{Operatives}, die in den Zustand der Inaktivität wechseln
aus der Liste der aktiven \emph{Operatives} entfernt und in die
Liste der inaktiven eingefügt. Der Berechnungszustand eines \emph{Operatives}
muss feststehen, da inaktive \emph{Operatives} aktiviert werden
müssen wenn ein neues \emph{Problem} vom \emph{Problem-Manager} instanziert
werden soll. Daher wird sowohl in der Methode zur \emph{Operative}-Reaktivierung
als auch in der Methode zur Ermittlung eines \emph{Teilproblems} für
einen \emph{Operative} (siehe Abbildung \ref{fig:distributePartialProblem})
auf die Liste der inaktiven \emph{Operatives} synchronisiert.
Da aber die gesamte Methode für die Ermittlung eines \emph{Teilproblems}
für einen \emph{Operative} auf diese Liste synchronisiert werden
muss, kann sie jeweils nur einen \emph{Operative} zur gleichen
Zeit mit einem \emph{Teilproblem} versorgen. Dies kann (abhängig von
der verwendeten Java-VM) zu Geschwindigkeitseinbußen besonders auf
Multiprozessorsystemen führen und darüber hinaus wird das System stark
blockiert, wenn es zu Verzögerungen bei der Teilproblemübergabe an
einen \emph{Operative} kommt. Insbesondere wird das gesamte System blockiert, wenn eine Methode zur Erzeugung eines \emph{Teilproblems} oder eine Methode zur Verarbeitung einer \emph{Teillösung} nicht endet. Wir haben versucht diese Nachteile
mit folgenden Lösungsansatz zu umgehen:

Instanziert der Problem-Manager ein neues Problem, so kann unmittelbar
nach der Instanzierung aktiven Operatives bei Bedarf ein \emph{Teilproblem}
dieses Problems zugewiesen werden. Die Methode zur \emph{Operative}-Reaktivierung
sowie auch die Methode zur Ermittlung eines \emph{Teilproblems} für
einen \emph{Operative} (siehe Abbildung \ref{fig:distributePartialProblem})
wurden auf das InfoOperative-Objekt des \emph{Operatives} synchronisiert,
der reaktiviert werden beziehungsweise ein \emph{Teilproblem} erhalten
soll. Gelingt die Übergabe eines \emph{Teilproblems} an den \emph{Operative},
so bleibt er aktiv und darf nicht reaktiviert werden. Anderenfalls
wird der \emph{Operative} inaktiv gesetzt und muss reaktiviert
werden. Die Reaktivierungsmethode funktioniert nun wie folgt: Bevor
überhaupt ein \emph{Operative} reaktiviert wird, muss auf sein
InfoOperative-Objekt synchronisiert werden. Sobald man diese Synchronisation
erhalten hat weiß man, dass der \emph{Operative} nun entweder
dabei ist, ein \emph{Teilproblem} zu berechnen oder in die Liste der
inaktiven \emph{Operatives} übernommen wurde. Anschließend gibt
man die Synchronisation des InfoOperative-Objekts wieder frei.
Dieses Vorgehen wiederholt man für alle \emph{Operatives} die
beim \emph{Compute-Manager} angemeldet sind. Danach kann man alle inaktiven
\emph{Operatives} reaktivieren. Im Unterschied zum derzeit implementierten
Vorgehen, würde bei diesem nicht ständig auf die Liste der inaktiven
\emph{Operatives} synchronisiert werden, sondern immer auf verschiedene
InfoOperative-Objekte.

Leider funktionierte unsere Realisierung des oben beschriebenen Reaktivierungsprinzips
für inaktive \emph{Operatives} nicht ohne Nebeneffekte. Besonders,
wenn die Verbindung zu \emph{Operatives} abbrach, wurde die Statistik
des \emph{ComputeSystems} inkonsistent und kurz darauf traten Deadlocks
ein. Darüber hinaus wurden viele \emph{Operatives} gar nicht oder
nur in sehr großen Zeitabständen mit \emph{Teilproblemen} versorgt.
Wir konnten uns diese Effekte nicht erklären und haben uns schließlich
für das stabile, etwas ineffizientere Reaktivierungsprinzip entschieden.


\subsection*{Entfernung eines abgestürzten Problems aus dem System}

Schickt ein Benutzer des \emph{ComputeSystems} ein \emph{Problem}
in das System, bei dem zum Beispiel die Abholung von \emph{Teilproblemen}
unendlich lange dauert, so wird das gesamte System blockiert. Es wäre
deshalb wünschenswert, dass ein abgestürztes \emph{Problem} aus dem
System entfernt werden kann. Hierzu müssten aber sinnvollerweise Benutzergruppen
vom \emph{ComputeSystem} verwaltet werden. Schließlich sollte nicht
jeder das \emph{Problem} eines anderen stoppen und entfernen können.
Außerdem müssen bestimmte Operative-RMI-Threads gestoppt werden,
wenn vom zu entfernenden \emph{Problem} gerade \emph{Teilprobleme}
abgeholt werden. Darüber hinaus muss sichergestellt werden, dass auch
die Synchronisationen, die diese Threads erhalten haben, wieder freigegeben
werden, da anderenfalls mit hoher Wahrscheinlichkeit Deadlocks auftreten
würden. Diese aufwendige Aufgabe konnte im Rahmen unseres Softwarepraktikums
nicht realisiert werden.

\appendix


\section{Sequenzdiagramme}

Die folgenden Sequenzdiagramme beschreiben den Teillösungsrückgabe-Teilproblemempfangs-Zyklus. Dabei werden verschiedene Abläufe betrachtet.


\subsection{Teillösung erfolgreich zurückgegeben}

Abbildung \ref{fig:Teilloesungerfolgreich} gibt einen Überblick über
einen normalen Ablauf des Zyklus. Dabei wird nicht beachtet, woher
das nächste \emph{Teilproblem} geholt wird. \begin{figure}[h]

   \begin{center} 

      \includegraphics[width=450pt]{Teilloesungerfolgreich.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Überblick über den normalen Ablauf des Teillösungsrückgabe-Teilproblemempfangs-Zyklus} 

      \label{fig:Teilloesungerfolgreich} 

   \end{center} 

\end{figure} 


\subsection{Vergabe eines bevorzugten Teilproblems}

Abbildung \ref{fig:bevorzugtesTeilproblem} zeigt, wie der Zyklus
durchlaufen wird, falls es bevorzugte \emph{Teilprobleme} gibt. Ein
Teilproblem heißt bevorzugt, wenn es nur von einem \emph{Operative}
berechnet wurde, zu dem die Kommunikation abgebrochen ist, noch bevor
eine \emph{Teillösung} für das \emph{Teilproblem} zurückgeschickt
werden konnte.\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=\textwidth]{bevorzugtesTeilproblem.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Vergabe eines bevorzugten Teilproblems} 

      \label{fig:bevorzugtesTeilproblem} 

   \end{center} 

\end{figure} 


\subsection{Vergabe eines neuen Teilproblems}

In Abbildung \ref{fig:neuesTeilproblem} wird der normale Ablauf der
Teilproblemvergabe dargestellt. In ihm wird ein neues \emph{Teilproblem}
von einem \emph{Problem} generiert und an einem \emph{Operative} vergeben.
\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=450pt]{neuesTeilproblem.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Vergabe eines neuen Teilproblems} 

      \label{fig:neuesTeilproblem} 

   \end{center} 

\end{figure} 


\subsection{Vergabe eines Teilproblems, dass bereits von einem anderen Operative
berechnet wird}

Der Fall der Mehrfachvergabe eines Teilproblems (siehe Abbildung \ref{fig:berechnetesTeilproblem})
tritt ein, wenn weder ein bevorzugtes noch ein neues \emph{Teilproblem}
existiert, aber noch \emph{Teilprobleme} von anderen \emph{Operatives} 
berechnet werden. 
Es wird also ein \emph{Teilproblem} vergeben, dass bereits
von einem anderen \emph{Operative} berechnet wird.\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=650pt]{berechnetesTeilproblem.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Mehrfachvergabe von Teilproblemen} 

      \label{fig:berechnetesTeilproblem} 

   \end{center} 

\end{figure} 


\subsection{Gesamtlösung existiert unmitteilbar nach Teillösungsrückgabe}

In Abbildung \ref{fig:Gesamtloesungsverarbeitung} ist der Fall dargestellt,
dass die \emph{Gesamtlösung} unmittelbar nach der Rückgabe einer \emph{Teillösung}
feststeht.\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=650pt]{gesamtloesungsverarbeitung.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Gesamtlösung existiert unmitteilbar nach Teillösungsrückgabe} 

      \label{fig:Gesamtloesungsverarbeitung} 

   \end{center} 

\end{figure} 


\subsection{Problem liefert kein neues Teilproblem}

Nach der \emph{Gesamtlösung} wird gefragt, falls kein \emph{Teilproblem}
vom \emph{Problem} generiert wurde. Dieser Fall wird in Abbildung
\ref{fig:Gesamtloesungsverarbeitung2} dargestellt.\begin{figure}[h]

   \begin{center} 

      \includegraphics[height=650pt]{gesamtloesungsverarbeitung2.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Problem liefert kein neues Teilproblem} 

      \label{fig:Gesamtloesungsverarbeitung2} 

   \end{center} 

\end{figure} 


\subsection{Rückgabe einer Teillösung für ein bereits berechnetes Problem}

Nachdem ein \emph{Problem} eine \emph{Gesamtlösung} geliefert hat
und deshalb aus der Liste der \emph{Probleme} entfernt wurde, kann
es vorkommen, dass die Berechnung des \emph{Teilproblems}, dessen \emph{Teillösung}
als einzige dem \emph{Problem} für die Gesamtlösung gefehlt hat, auf
anderen \emph{Operatives} noch nicht abgebrochen werden konnte.
In diesem Fall wird die \emph{Teillösung} der anderen \emph{Operatives}
verworfen. Dieser Vorgang ist in Abbildung \ref{fig:Problemnichtmehrda}
dargestellt.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=\textwidth]{Problemnichtmehrda.eps}         

      %\setcaptionwidth{\textwidth} 

      \caption{Rückgabe einer Teillösung für eine bereits berechnetes Problem} 

      \label{fig:Problemnichtmehrda} 

   \end{center} 

\end{figure} 


\subsection{Rückgabe einer Teillösung zu einem bereits berechneten Teilproblem}

Abbildung \ref{fig:Teilloesungnichterfolgreich} beschreibt den Fall, dass eine \emph{Teillösung} zu einem mehrfach vergebenen
\emph{Teilproblem} von mehreren \emph{Operatives} gleichzeitig
gesendet wird, wird nur von einem die \emph{Teillösung} angenommen.
Wird diese \emph{Teillösung} noch von anderen \emph{Operatives}
zurückgeliefert, so wird sie verworfen. Der Operative-RMI-Thread,
dessen \emph{Teillösung} angenommen wurde, bricht die Berechnung des
\emph{Teilproblems} auf den übrigen \emph{Operatives} ab und sorgt
dafür, dass sie ein neues \emph{Teilproblem} erhalten.

\begin{figure}[h]

   \begin{center} 

      \includegraphics[width=\textwidth]{Teilloesungnichterfolgreich.eps}               %\setcaptionwidth{\textwidth} 

      \caption{Rückgabe einer Teillösung zu einem bereits berechneten Teilproblem} 

      \label{fig:Teilloesungnichterfolgreich} 

   \end{center} 

\end{figure} 
\end{document}
